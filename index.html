<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Von Felix der Geile Vokabeltrainer</title>
    <link rel="website Icon" href="Hund.jpg">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc;
        }
        
        /* Basisstil fÃ¼r die Karte (Train View) */
        #flashcard {
            width: 100%;
            height: 400px; 
            max-height: 60vh;
            perspective: 1000px;
            position: relative;
            cursor: pointer; 
        }

        .flashcard-inner {
            width: 100%;
            height: 100%;
            transition: transform 0.6s; 
            transform-style: preserve-3d;
            position: relative;
        }

        .flashcard.flipped .flashcard-inner {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.75rem;
            padding: 2.5rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        /* Mobile adjustments */
        @media (max-width: 640px) {
            #flashcard {
                height: 260px;
            }
            .flashcard-front, .flashcard-back {
                padding: 0.75rem;
                border-width: 3px;
            }
            .flashcard-front p, .flashcard-back p {
                font-size: 1rem;
                line-height: 1.15;
                white-space: normal;
                word-break: break-word;
                hyphens: auto;
                margin: 0;
            }
            #cardContainer {
                padding: 0.5rem;
            }
            #answerInput {
                padding: 0.75rem;
            }
            .nav-button {
                padding: 0.5rem 0.75rem;
                font-size: 0.9rem;
            }
            .match-card {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
        }
        
        .flashcard-front {
            background-color: white;
            border: 4px solid #3b82f6; 
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background-color: #eff6ff; 
            border: 4px solid #60a5fa; 
            color: #1d4ed8; 
        }

        /* Liste Styling */
        .list-header {
            background-color: #4f46e5; /* Indigo 600 */
            color: white;
        }

        /* Test Modul Styling */
        .test-question-item[data-status="correct"] {
            background-color: #d1fae5; 
            border-left-color: #10b981; 
        }
        .test-question-item[data-status="incorrect"] {
            background-color: #fee2e2; 
            border-left-color: #ef4444; 
        }
        .test-question-item[data-status="skipped"] {
            background-color: #fffbeb; 
            border-left-color: #f59e0b; 
        }
        .loading-indicator {
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #3498db; 
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Match It! Game Styling */
        .match-card {
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: 600;
        }
        .match-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .match-card-german {
            background-color: #fee2e2; /* Red 100 */
            color: #991b1b; /* Red 800 */
            border: 2px solid #ef4444;
        }
        .match-card-english {
            background-color: #dbeafe; /* Blue 100 */
            color: #1e40af; /* Blue 800 */
            border: 2px solid #3b82f6;
        }
        .match-card.selected {
            transform: scale(1.05);
            border: 3px solid #f59e0b; /* Amber */
            box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.5);
        }
        .match-card.matched {
            background-color: #d1fae5; /* Green 100 */
            color: #10b981; /* Green 600 */
            border: 3px solid #10b981;
            cursor: default;
            pointer-events: none; /* Deaktiviert Klicks */
            opacity: 0.5;
        }
        
        /* Hangman Game Styling */
        .hangman-word span {
            display: inline-block;
            width: 1.5rem;
            height: 2rem;
            line-height: 2rem;
            text-align: center;
            margin: 0 2px;
            border-bottom: 3px solid #4f46e5;
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e40af;
        }
        .hangman-keyboard button {
            width: 40px;
            height: 40px;
            margin: 3px;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .hangman-keyboard button:disabled {
            background-color: #ccc;
            color: #888;
            cursor: not-allowed;
            opacity: 0.7;
        }

        /* Quiz Time Styling */
        .mc-option {
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 0.75rem;
            background-color: #fff;
            border: 2px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .mc-option:hover {
            border-color: #93c5fd; /* Blue 300 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .mc-option.correct {
            background-color: #d1fae5; /* Green 100 */
            border-color: #10b981; /* Green 500 */
            color: #065f46;
            font-weight: bold;
            pointer-events: none;
        }
        .mc-option.incorrect {
            background-color: #fee2e2; /* Red 100 */
            border-color: #ef4444; /* Red 500 */
            color: #991b1b;
            font-weight: bold;
            pointer-events: none;
        }
        .mc-option.selected {
            background-color: #bfdbfe; /* Blue 200 */
            border-color: #3b82f6;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="max-w-xl mx-auto">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-6 text-center">Vokabel-Trainer</h1>
        
        <div id="navigation" class="flex flex-wrap justify-center gap-2 mb-8">
            <button class="nav-button bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg transition-colors duration-150" onclick="showView('home')">
                ğŸ  Home
            </button>
            <button class="nav-button bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg transition-colors duration-150" onclick="showView('train')">
                ğŸ§  Lernen
            </button>
            <button class="nav-button bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-lg transition-colors duration-150" onclick="showView('list')">
                ğŸ“š Liste
            </button>
        </div>


        <div id="home-view" class="view">
            <div class="p-8 bg-white rounded-xl shadow-2xl text-center">
                <h2 class="text-2xl font-bold text-gray-800 mb-6">WÃ¤hle dein Lernmodul</h2>
                <div class="space-y-4">
                    <button class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-8 text-lg rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('train')">
                        ğŸ§  Vokabeln lernen (Karteikarten)
                    </button>
                    <button class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('list')">
                        ğŸ“š Vokabelliste anzeigen (Alle)
                    </button>
                    <button class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('test')">
                        ğŸ“ Vokabel-Test (15 Fragen)
                    </button>
                    <button class="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('games')">
                        ğŸ® Vokabel Spiele
                    </button>
                    <button class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('manage')">
                        âš™ï¸ Vokabeln hinzufÃ¼gen & verwalten
                    </button>
                    <button class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="showView('settings')">
                        âš¡ Einstellungen
                    </button>
                </div>
            </div>
            
            <div class="mt-8 p-6 bg-white rounded-xl shadow-2xl">
                <div class="flex justify-between items-center mb-4 border-b pb-3">
                    <h2 class="text-2xl font-bold text-gray-800">ğŸ“¦ Dein Lernfortschritt</h2>
                    <div class="text-center">
                        <p class="text-3xl font-extrabold" id="streak-display">ğŸ”¥ 0</p>
                        <p class="text-xs text-gray-600 mt-1">Tage Streak</p>
                    </div>
                </div>
                <div id="box-stats-home" class="space-y-4">
                    </div>
                <p class="mt-4 text-sm text-gray-500 text-center">Klicken Sie auf einen Kasten, um alle darin enthaltenen Vokabeln zu sehen.</p>
            </div>

            <div class="mt-8 p-4 bg-white rounded-3xl shadow-2xl">
                <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">ğŸ“… Testplan - Diese Woche</h2>
                
                <div class="mb-6 p-4 bg-gradient-to-r from-orange-100 to-yellow-100 rounded-3xl border-2 border-orange-300">
                    <div class="flex justify-between items-center">
                        <div>
                            <p class="text-sm text-gray-700 font-semibold">ğŸ”¥ Dein Streak</p>
                            <p class="text-4xl font-bold text-orange-600" id="calendarStreakDisplay">0</p>
                        </div>
                        <div class="text-right">
                            <p class="text-sm text-gray-700 font-semibold">NÃ¤chster Test</p>
                            <p class="text-2xl font-bold text-orange-500" id="nextTestCountdown">-</p>
                        </div>
                    </div>
                </div>

                <div class="mb-6">
                    <div class="grid grid-cols-7 gap-2" id="weekCalendarContainer">
                        <!-- Wochentage werden hier eingefÃ¼gt -->
                    </div>
                </div>

                <div class="p-4 bg-blue-50 rounded-3xl border-2 border-blue-300 text-center">
                    <p class="text-sm text-gray-700 font-semibold">ğŸ’¡ Klick auf einen Tag, um einen Test hinzuzufÃ¼gen</p>
                </div>
            </div>

            <div class="mt-8 p-6 bg-white rounded-xl shadow-2xl">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center border-b pb-3">ğŸ“ˆ Dein Lernverlauf</h2>
                <div class="relative" style="height: 300px;">
                    <canvas id="progressChart"></canvas>
                </div>
                <p class="mt-4 text-sm text-gray-600 text-center">Zeigt deine tÃ¤glichen Vokabel-Trainings Ã¼ber die Zeit</p>
                <p class="mt-2 text-xs text-gray-500 text-center italic">ğŸ’¡ GezÃ¤hlt: nur korrekt markierte Vokabeln pro Tag</p>
            </div>
        </div>
        
        <div id="train-view" class="view hidden">
            <div class="max-w-xl mx-auto">
                <div class="mb-4 flex justify-end">
                    <button id="cancelTrainButton" class="bg-red-400 hover:bg-red-500 text-white font-bold py-1 px-3 rounded-lg text-sm transition-colors duration-150 hidden" onclick="cancelTraining()">
                        âœ• Beenden
                    </button>
                </div>
                 <div class="p-4 bg-yellow-100 rounded-xl shadow-md mb-6 border border-yellow-300">
                    <h3 class="text-lg font-bold text-gray-800 mb-3 text-center">Kasten-Auswahl fÃ¼r das Training:</h3>
                    <div id="box-selection-container" class="flex flex-wrap justify-center gap-3">
                        </div>
                    <div class="mt-3 text-center">
                        <label for="directionSelect" class="mr-2 font-medium text-gray-700">Richtung:</label>
                        <select id="directionSelect" class="p-2 border rounded-lg text-sm">
                            <option value="de->en">Deutsch â†’ Englisch (Standard)</option>
                            <option value="en->de">Englisch â†’ Deutsch</option>
                        </select>
                    </div>
                </div>
                 <div class="mb-6 text-center text-sm font-medium text-gray-600">
                    Gelernt: <span id="currentCardIndex">0</span> von <span id="totalCards">21</span> Vokabeln
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5 mb-8">
                    <div id="progressBar" class="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>

                <div class="flex justify-center space-x-2 text-center text-xs mb-4">
                    <span id="box-stats" class="text-gray-500">Boxen-Statistik wird geladen...</span>
                </div>
                <div id="cardContainer" class="bg-white rounded-xl shadow-2xl mb-8 p-4">
                    <div id="flashcard" class="flashcard w-full mb-6" onclick="handleCardClick()"> 
                        <div class="flashcard-inner">
                            <div id="cardFront" class="flashcard-front">
                                <p class="text-2xl font-bold text-gray-800">Klicke auf START</p>
                            </div>
                            <div id="cardBack" class="flashcard-back">
                                <p class="text-2xl font-semibold"></p>
                            </div>
                        </div>
                    </div>

                    <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                        <p id="feedback" class="text-center font-semibold mb-4 text-lg text-gray-700 h-6"></p>

                        <input type="text" id="answerInput" placeholder="Antwort..." class="p-3 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:bg-gray-200 text-sm" disabled>
                        
                        <div class="mt-4 space-y-2">
                            <button id="checkButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95" onclick="checkAnswer()" disabled>
                                Antwort Ã¼berprÃ¼fen
                            </button>
                            <button id="showAnswerButton" class="w-full bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95 hidden" onclick="handleCardClick()">
                                ğŸ”„ Karte umdrehen / Antwort anzeigen
                            </button>
                            
                        </div>

                        <div id="nextActions" class="mt-6 space-y-3 hidden">
                            <p class="text-center text-sm font-medium text-gray-600">WÃ¤hle Status und gehe zur nÃ¤chsten Karte:</p>
                                <div class="flex flex-col sm:flex-row gap-2 sm:space-x-3">
                                    <button class="w-full sm:flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="processResult(true)">
                                        âœ… Korrekt (NÃ¤chste Box)
                                    </button>
                                    <button class="w-full sm:flex-1 bg-red-500 hover:bg-red-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="processResult(false)">
                                        âŒ Falsch (Box 1)
                                    </button>
                                </div>
                        </div>
                        
                        <button id="startButton" class="w-full mt-4 bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95" onclick="startTrainGame()">
                            START
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="list-view" class="view hidden p-4 bg-white rounded-xl shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Vokabelliste (Deutsch â†” Englisch)</h2>
             <p id="list-filter-info" class="text-center text-sm text-gray-600 mb-4 font-semibold">Alle Vokabeln werden angezeigt.</p>
            
            <div class="mb-6">
                <input type="text" id="vocabularySearchInput" placeholder="ğŸ” Vokabel suchen (Deutsch oder Englisch)..." class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:outline-none focus:border-blue-500 focus:ring-2 focus:ring-blue-200 transition-colors">
            </div>
            
            <div class="overflow-x-auto rounded-lg border border-gray-200">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="list-header">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">
                                Deutsch (German)
                            </th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium uppercase tracking-wider">
                                Englisch (English)
                            </th>
                             <th scope="col" class="px-6 py-3 text-center text-xs font-medium uppercase tracking-wider">
                                Box
                            </th>
                             <th scope="col" class="px-6 py-3 text-right text-xs font-medium uppercase tracking-wider">
                                Aktion
                            </th>
                        </tr>
                    </thead>
                    <tbody id="vocabularyListBody" class="bg-white divide-y divide-gray-200">
                        </tbody>
                </table>
            </div>
            <p class="mt-4 text-sm text-gray-500 text-center">Gesamtzahl der Vokabeln: <span id="listTotalCount"></span></p>
        </div>

        <div id="test-view" class="view hidden p-4 bg-white rounded-xl shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center border-b pb-4">ğŸ“ Vokabel-Test</h2>
            <div class="flex justify-center mb-4">
                <label for="testDirectionSelect" class="mr-2 font-medium text-gray-700">Abfrage-Richtung:</label>
                <select id="testDirectionSelect" class="p-2 border rounded-lg text-sm">
                    <option value="de->en">Deutsch â†’ Englisch (Standard)</option>
                    <option value="en->de">Englisch â†’ Deutsch</option>
                </select>
            </div>
            <div id="test-container">
                <p id="test-info" class="text-center text-gray-600 mb-6"></p>

                <div id="test-questions" class="space-y-6">
                    </div>

                <div class="mt-8">
                    <button id="submitTestButton" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-4 rounded-xl shadow-lg transition-transform duration-150 active:scale-95 hidden" onclick="submitTest()">
                        Test beenden und korrigieren
                    </button>
                </div>
                <div class="mt-4">
                     <button id="startTestButton" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95" onclick="startTest()">
                        Test starten (15 Vokabeln)
                    </button>
                </div>
            </div>

            <div id="test-results" class="hidden mt-8 p-6 border-4 border-red-500 rounded-xl bg-red-50">
                <h3 class="text-3xl font-extrabold text-red-700 text-center mb-4">Ergebnis des Vokabeltests</h3>
                <div class="grid grid-cols-2 gap-4 text-center mb-6">
                    <div class="p-4 bg-white rounded-lg shadow">
                        <p class="text-sm text-gray-500">Korrekte Antworten</p>
                        <p id="result-correct" class="text-2xl font-bold text-green-600">-</p>
                    </div>
                    <div class="p-4 bg-white rounded-lg shadow">
                        <p class="text-sm text-gray-500">Fehler / Leer</p>
                        <p id="result-incorrect" class="text-2xl font-bold text-red-600">-</p>
                    </div>
                </div>
                
                <div class="p-6 bg-red-100 rounded-xl mb-6">
                    <p class="text-sm text-red-800 font-semibold text-center">DEINE NOTE</p>
                    <p id="result-grade" class="text-6xl font-black text-red-900 text-center mt-1">-</p>
                </div>
                
                <!-- Entfernt: Button redundant, da Ergebnisse nach Korrektur automatisch neu berechnet werden -->

                <h4 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Detaillierte Korrektur (Manuell anpassbar)</h4>
                <div id="test-correction" class="space-y-4">
                    </div>
                
                <button class="w-full mt-8 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-xl transition-transform active:scale-95" onclick="showView('home')">
                    ZurÃ¼ck zum Start
                </button>
            </div>
        </div>

        <div id="manage-view" class="view hidden p-4 bg-white rounded-xl shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center border-b pb-4">âš™ï¸ Vokabeln hinzufÃ¼gen & verwalten</h2>
            
            <div class="p-6 bg-blue-50 rounded-xl border-4 border-blue-300 shadow-lg mb-8">
                <h3 class="text-xl font-bold text-blue-700 mb-4">â• Manuell Vokabeln hinzufÃ¼gen</h3>
                
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1" for="germanInput">Deutsch (German):</label>
                        <input type="text" id="germanInput" placeholder="z.B. seinen Horizont erweitern" class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1" for="englishInput">Englisch (English):</label>
                        <input type="text" id="englishInput" placeholder="z.B. to broaden one's horizons" class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1" for="exampleInput">Beispielsatz (optional, fÃ¼r LÃ¼ckenfÃ¼ller):</label>
                        <input type="text" id="exampleInput" placeholder="z.B. Travel helps to [VOCAB]." class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>

                <button class="w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="addManualVocabulary()">
                    Vokabel-Paar hinzufÃ¼gen
                </button>
                <p id="manual-status" class="text-center font-semibold mt-3 h-6 text-sm"></p>
            </div>

            <div class="p-6 bg-teal-50 rounded-xl border-4 border-teal-300 shadow-lg relative">
                <h3 class="text-xl font-bold text-teal-700 mb-4">ğŸ“¸ Vokabeln per Foto hinzufÃ¼gen (KI)</h3>

                <p class="text-gray-600 mb-4 text-sm">WÃ¤hlen Sie ein Bild mit Vokabelpaaren. Die KI liest die Vokabeln aus und fÃ¼gt sie Ihrer Liste hinzu.</p>

                <label class="block text-sm font-medium text-gray-700 mb-2" for="imageUpload">
                    1. Foto auswÃ¤hlen:
                </label>
                <input type="file" id="imageUpload" accept="image/*" class="w-full p-2 border border-gray-300 rounded-lg mb-4" disabled>

                <button id="scanButton" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-3 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="extractVocabularyFromImage()" disabled>
                    Vokabeln scannen und extrahieren
                </button>
                
                <div id="add-status" class="mt-4 flex items-center justify-center space-x-3 h-10"></div>

                <div id="image-preview-container" class="mt-6 p-4 border border-gray-200 rounded-lg hidden">
                    <p class="text-sm font-semibold text-gray-700 mb-2">Vorschau des gescannten Bildes:</p>
                    <img id="image-preview" class="max-w-full h-auto rounded-md border" alt="Vorschau des hochgeladenen Bildes">
                </div>

                <div id="extracted-list-container" class="mt-6 hidden">
                    <h4 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Gefundene Vokabeln (<span id="extractedCount">0</span>)</h4>
                    <div id="extracted-list" class="space-y-2"></div>
                </div>

                <div id="editable-extracted-container" class="mt-6 p-4 bg-blue-50 rounded-lg border border-blue-300"></div>

                <!-- Visuelle, halbtransparente Ãœberlagerung - deaktiviert und zentrierte Hauptmeldung -->
                <div aria-hidden="true" style="position:absolute;inset:0;background:rgba(120,120,120,0.78);backdrop-filter: blur(1px);z-index:30;display:flex;align-items:center;justify-content:center;padding:0;border-radius:0.5rem;">
                    <div style="text-align:center;max-width:80%;">
                        <div style="background:rgba(255,255,255,0.03);padding:14px 18px;border-radius:12px;">
                            <p style="color:#ff0000;font-weight:900;font-size:1.5rem;line-height:1.2;margin:0;">ğŸ”´ Die Funktion ist vorÃ¼bergehend deaktiviert</p>
                        </div>
                    </div>
                </div>
            </div>
            
        </div>

        <div id="edit-vocab-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full mx-4">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3">âœï¸ Vokabel bearbeiten</h2>
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Deutsch:</label>
                        <input type="text" id="edit-german-input" class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Englisch:</label>
                        <input type="text" id="edit-english-input" class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Beispielsatz (optional):</label>
                        <input type="text" id="edit-example-input" class="p-2 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="flex gap-3 pt-4">
                        <button class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg" onclick="saveEditedVocab()">ğŸ’¾ Speichern</button>
                        <button class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 rounded-lg" onclick="closeEditVocabModal()">âŒ Abbrechen</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings-view" class="view hidden p-4 bg-white rounded-xl shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center border-b pb-4">âš¡ Einstellungen</h2>
            
            <div class="space-y-6">
                <div class="p-6 bg-red-50 rounded-xl border-4 border-red-300 shadow-lg">
                    <h3 class="text-xl font-bold text-red-700 mb-3">ğŸ—‘ï¸ Datenbank zurÃ¼cksetzen</h3>
                    <p class="text-gray-700 mb-4">LÃ¶schen Sie alle Ihre Vokabeln und Lernfortschritte. Diese Aktion kann NICHT rÃ¼ckgÃ¤ngig gemacht werden!</p>
                    <button class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="confirmClearDatabase()">
                        ğŸ—‘ï¸ Alle Daten lÃ¶schen (Neustart)
                    </button>
                </div>

                <div class="p-6 bg-green-50 rounded-xl border-4 border-green-300 shadow-lg mt-4">
                    <h3 class="text-xl font-bold text-green-700 mb-3">ğŸ“š Nur Vokabeln zurÃ¼cksetzen</h3>
                    <p class="text-gray-700 mb-4">LÃ¤dt nur die Standard-Vokabeln (~36 EintrÃ¤ge). Ihr Trainingsfortschritt bleibt erhalten.</p>
                    <button class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="confirmResetVocabularyOnly()">
                        ğŸ“š Vokabeln auf Standard zurÃ¼cksetzen
                    </button>
                </div>

                <div class="p-6 bg-yellow-50 rounded-xl border-4 border-yellow-300 shadow-lg mt-4">
                    <h3 class="text-xl font-bold text-yellow-700 mb-3">ğŸ” Werkseinstellungen (alles zurÃ¼cksetzen)</h3>
                    <p class="text-gray-700 mb-4">Setzt Fortschritte zurÃ¼ck und lÃ¤dt die Standard-Vokabeln (~36 EintrÃ¤ge). Die App bleibt betriebsbereit.</p>
                    <button id="resetDefaultsButton" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 rounded-xl shadow-lg transition-transform duration-150 active:scale-95" onclick="confirmResetToDefaults()">
                        ğŸ” Alles zurÃ¼cksetzen (Fortschritt + Vokabeln)
                    </button>
                </div>

                <div class="p-6 bg-blue-50 rounded-xl border-4 border-blue-300 shadow-lg">
                    <h3 class="text-xl font-bold text-blue-700 mb-3">ğŸ“Š Lernstatistiken</h3>
                    <div id="stats-summary" class="text-gray-700">
                        <p><strong>Gesamtzahl Vokabeln:</strong> <span id="total-vocabs">0</span></p>
                        <p><strong>Letztes Training:</strong> <span id="last-trained">Noch nicht trainiert</span></p>
                        <p><strong>Trainingssitzungen:</strong> <span id="training-sessions">0</span></p>
                    </div>
                </div>

                <div class="p-6 bg-purple-50 rounded-xl border-4 border-purple-300 shadow-lg">
                    <h3 class="text-xl font-bold text-purple-700 mb-3">ğŸ“ Trainings-Log</h3>
                    <p class="text-sm text-gray-600 mb-3">Letzte Trainings mit Zeitstempel, korrekten Antworten und Erfolgsquote. Klick auf einen Eintrag fÃ¼r Details:</p>
                    <div id="training-log-container" class="text-gray-700">
                        <!-- Wird von renderTrainingLog() gefÃ¼llt -->
                    </div>
                </div>

                <button class="w-full mt-8 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-xl transition-transform active:scale-95" onclick="showView('home')">
                    â† ZurÃ¼ck zur Startseite
                </button>
            </div>
        </div>

        <div id="session-details-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-xl shadow-2xl p-6 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto">
                <div id="session-details-content">
                    <!-- Wird von showSessionDetails() gefÃ¼llt -->
                </div>
            </div>
        </div>

        <div id="games-view" class="view hidden p-4 bg-white rounded-xl shadow-2xl">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center border-b pb-4">ğŸ® Interaktive Vokabel Spiele</h2>
            
            <div class="space-y-6">
                
                <div class="p-6 bg-yellow-50 rounded-xl border-4 border-yellow-300 shadow-lg">
                    <h3 class="text-xl font-bold text-yellow-700 mb-3 flex items-center">
                        <span class="text-3xl mr-2">ğŸ–‹ï¸</span> LÃ¼ckenfÃ¼ller (Fill-in-the-Blank)
                    </h3>
                    <p class="text-gray-700 mb-4">Ãœbersetze die Vokabel, die in einem Beispielsatz fehlt (10 Fragen).</p>
                    <button class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="startGame('fill-in-blank')" id="start-fill-in-blank">
                        Spiel starten
                    </button>
                    <div id="fill-in-blank-container" class="mt-4 hidden">
                        <p class="text-center font-semibold mb-2">Frage <span id="fibCurrentQuestion">1</span> von 10</p>
                        <div class="p-4 bg-white rounded-lg shadow-inner mb-4">
                            <p class="text-lg text-gray-600 mb-2">FÃ¼lle die LÃ¼cke mit der korrekten englischen Ãœbersetzung von "<span id="fibGermanTerm" class="font-bold text-yellow-800"></span>" aus:</p>
                            <p id="fibSentence" class="text-xl font-medium text-gray-900 text-center p-3 border-b-2 border-dashed border-gray-300 italic"></p>
                        </div>
                        
                        <input type="text" id="fibAnswerInput" placeholder="Englische Antwort" class="p-3 border-2 border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-yellow-500">
                        
                        <div class="mt-4 space-y-2">
                            <button id="fibCheckButton" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95" onclick="checkFillInBlankAnswer()">
                                Antwort Ã¼berprÃ¼fen
                            </button>
                            <button id="fibNextButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-xl shadow-md transition-transform duration-150 active:scale-95 hidden" onclick="loadNextFillInBlankQuestion()">
                                NÃ¤chste Frage
                            </button>
                        </div>

                        <p id="fibStatus" class="text-center font-semibold mt-4 h-6"></p>
                        
                        <div id="fibResults" class="p-6 bg-yellow-100 rounded-xl mt-6 hidden">
                            <h4 class="text-2xl font-bold text-yellow-800 text-center mb-4">Dein LÃ¼ckenfÃ¼ller-Ergebnis</h4>
                            <p class="text-center text-lg">Du hast <span id="fibScore" class="font-extrabold text-yellow-700 text-3xl">0</span> von 10 Fragen richtig beantwortet!</p>
                            <button class="w-full mt-4 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 rounded-xl transition-transform active:scale-95" onclick="showView('games')">
                                ZurÃ¼ck zu den Spielen
                            </button>
                        </div>
                    </div>
                </div>

                <div class="p-6 bg-green-50 rounded-xl border-4 border-green-300 shadow-lg">
                    <h3 class="text-xl font-bold text-green-700 mb-3 flex items-center">
                        <span class="text-3xl mr-2">â“</span> Quiz Time! (Multiple Choice)
                    </h3>
                    <p class="text-gray-700 mb-4">WÃ¤hle die korrekte englische Ãœbersetzung zur deutschen Vokabel (10 Fragen).</p>
                    <button class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="startGame('quiz-time')" id="start-quiz-time">
                        Spiel starten
                    </button>
                    
                    <div id="quiz-time-container" class="mt-4 hidden">
                        <p class="text-center font-semibold mb-2">Frage <span id="quizCurrentQuestion">1</span> von 10</p>
                        <div class="p-4 bg-white rounded-lg shadow-inner mb-4">
                            <p class="text-lg text-gray-600 mb-2">Deutsche Vokabel:</p>
                            <p id="quizGermanTerm" class="text-2xl font-bold text-green-900 text-center"></p>
                        </div>
                        
                        <div id="quizOptions" class="space-y-2">
                            </div>

                        <p id="quizStatus" class="text-center font-semibold mt-4 h-6"></p>
                        <div class="flex justify-center mt-6">
                            <button id="quizNextButton" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-xl transition-transform duration-150 active:scale-95 hidden" onclick="loadNextQuizQuestion()">
                                NÃ¤chste Frage
                            </button>
                        </div>
                         <div id="quizResults" class="p-6 bg-blue-100 rounded-xl mt-6 hidden">
                            <h4 class="text-2xl font-bold text-blue-800 text-center mb-4">Dein Quiz-Ergebnis</h4>
                            <p class="text-center text-lg">Du hast <span id="quizScore" class="font-extrabold text-blue-700 text-3xl">0</span> von 10 Fragen richtig beantwortet!</p>
                            <button class="w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-xl transition-transform active:scale-95" onclick="showView('games')">
                                ZurÃ¼ck zu den Spielen
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="p-6 bg-red-50 rounded-xl border-4 border-red-300 shadow-lg">
                    <h3 class="text-xl font-bold text-red-700 mb-3 flex items-center">
                        <span class="text-3xl mr-2">ğŸ”—</span> Match It! (Zuordnen)
                    </h3>
                    <p class="text-gray-700 mb-4">Ordne die deutschen und englischen Vokabeln per Klick zu.</p>
                    <button class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="startGame('match-it')" id="start-match-it">
                        Spiel starten
                    </button>
                    <div id="match-it-container" class="mt-4 hidden">
                        <div class="grid grid-cols-2 gap-3" id="match-cards">
                            </div>
                        <p id="match-status" class="text-center font-semibold mt-4 h-6"></p>
                    </div>
                </div>
                
                <div class="p-6 bg-indigo-50 rounded-xl border-4 border-indigo-300 shadow-lg">
                    <h3 class="text-xl font-bold text-indigo-700 mb-3 flex items-center">
                        <span class="text-3xl mr-2">âœï¸</span> Hangman (Galgenraten)
                    </h3>
                    <p class="text-gray-700 mb-4">Errate die englische Vokabel Buchstabe fÃ¼r Buchstabe anhand der deutschen Ãœbersetzung.</p>
                    <button class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 rounded-xl transition-transform duration-150 active:scale-95" onclick="startGame('hangman')" id="start-hangman">
                        Spiel starten
                    </button>
                    <div id="hangman-container" class="mt-4 hidden">
                        <div class="text-center p-4 bg-white rounded-lg shadow-inner mb-4">
                            <p class="text-lg text-gray-600 mb-2">Deutsche Vokabel:</p>
                            <p id="hangman-german" class="text-2xl font-bold text-indigo-900"></p>
                            <div class="flex justify-center mt-4">
                                <p id="hangman-word" class="hangman-word space-x-2"></p>
                            </div>
                            <p id="hangman-guesses" class="text-sm text-red-600 mt-2">Fehlversuche: <span id="hangman-mistakes">0</span> / 6</p>
                        </div>
                        
                        <div id="hangman-keyboard" class="hangman-keyboard flex flex-wrap justify-center mb-4">
                            </div>
                        
                        <p id="hangman-status" class="text-center font-semibold mt-4 h-6"></p>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <script>
        // â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        // â•‘  GEMINI API KEY KONFIGURATION                                               â•‘
        // â•‘  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• â•‘
        // â•‘  SCHRITT 1: Kopieren Sie Ihren Gemini API Key von hier:                     â•‘
        // â•‘             https://aistudio.google.com/apikey                              â•‘
        // â•‘  SCHRITT 2: Ersetzen Sie 'HIER_IHREN_API_KEY_EINSETZEN' mit Ihrem Key       â•‘
        // â•‘  BEISPIEL: window.GEMINI_API_KEY = 'AIza123456789...';                      â•‘
        // â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.GEMINI_API_KEY = 'HIER_IHREN_API_KEY_EINSETZEN';

        // ----------------------------------------------------------------------
        // 1. Initial Data, Constants, and Storage
        // ----------------------------------------------------------------------
        
        // Konstante fÃ¼r die Anzahl der Boxen im Kastensystem
        const NUM_BOXES = 5; 
        
        // Basis-Vokabeln, die nur beim ERSTEN Start verwendet werden, falls kein Local Storage vorhanden ist.
        // **NEU: Jede Vokabel erhÃ¤lt beim ersten Start die Eigenschaft 'box: 1'**
        const DEFAULT_VOCABULARY = [
            { german: "to adjust (to)", english: "einstellen, anpassen (an)", example: "It is still hard for me to adjust to living on the countryside.", box: 1 },
            { german: "response", english: "Antwort, Reaktion", example: "His sharp response confused me.", box: 1 },
            { german: "antidote", english: "Gegenmittel, Gegengift", example: "For Stephanie, riding the motorcycle on the weekend is the perfect antidote to the boredom of her office job.", box: 1 },
            { german: "cabin fever", english: "Lagerkoller, GefÃ¼hl der Beengtheit", example: "I easily suffer from cabin fever if I stay indoors for too long.", box: 1 },
            { german: "to mock", english: "(ver)spotten, (ver)hÃ¶hnen", example: "The popular students mocked the students who were bad at sport.", box: 1 },
            { german: "wisdom (no pl)", english: "Weisheit, Klugheit", example: "I always admired my grandfather's wisdom.", box: 1 },
            { german: "itinerary", english: "Reiseroute, Reiseplan", example: "When travelling on your own, it is a good idea to plan your itinerary in advance.", box: 1 },
            { german: "a kernel of truth", english: "ein KÃ¶rnchen Wahrheit", example: "I thought his speech was full of exaggerations, nonetheless there was a kernel of truth in what he said.", box: 1 },
            { german: "stretch", english: "Zeitraum, (Strecken)abschnitt, StÃ¼ck", example: "The final stretch of the season was very exhausting for the players.", box: 1 },
            { german: "crammed", english: "vollgestopft", example: "No wonder: the suitcase won't close â€“ look how crammed it is!", box: 1 },
            { german: "to tempt sb", english: "jdn in Versuchung fÃ¼hren", example: "Can I tempt you into eating meat with one of my delicious sausage rolls?", box: 1 },
            { german: "to long for sth", english: "sich nach etw sehnen", example: "I always long for the summer holidays.", box: 1 },
            { german: "handy", english: "praktisch, nÃ¼tzlich, griffbereit", example: "This tool is very handy when you need to join two pieces of wood or metal.", box: 1 },
            { german: "to fast forward (no pl)", english: "vorspulen", example: "Sometimes, I wish I could fast forward to the future.", box: 1 },
            { german: "tight", english: "fest, eng, hier: knapp", example: "My budget for this year's holiday is very tight, I wish I had saved more money.", box: 1 },
            { german: "minimum wage (no pl)", english: "Mindestlohn", example: "Last year, the minimum wage was raised by the government.", box: 1 },
            { german: "attendant", english: "Aufseher/in, WÃ¤rter/in, hier: Bademeister/in", example: "Last summer, my brother worked as an attendant at the local swimming pool.", box: 1 },
            { german: "aside from", english: "abgesehen von", example: "Aside from my summer job, I also receive a bit of money from my parents.", box: 1 },
            { german: "suburbia (no pl)", english: "Vororte, Randbezirke", example: "Suburbia is a term often used to connote the attitudes and habits of people living in the suburbs.", box: 1 },
            { german: "facility", english: "Anlage, Einrichtung", example: "There are a few recreational facilities near our place.", box: 1 },
            { german: "to cease", english: "(be)enden, aufhÃ¶ren", example: "At noon, the rain had suddenly ceased.", box: 1 },
            { german: "consequential", english: "folgerichtig, wichtig", example: "Did you make any consequential changes to the schedule since we last met?", box: 1 },
            { german: "burdensome", english: "belastend, mÃ¼hsam, lÃ¤stig", example: "My job has become quite burdensome in recent years.", box: 1 },
            { german: "post-graduate", english: "nach beendetem Studium", example: "After university, I spend my first post-graduate year doing odd jobs.", box: 1 },
            { german: "to loom", english: "(drohend) auftauchen", example: "Look at those storm clouds looming on the horizon â€“ it will rain pretty soon, I think!", box: 1 },
            { german: "to shed/throw light on sth", english: "Aufschluss Ã¼ber etw geben", example: "The article sheds light on the problem of homelessness.", box: 1 },
            { german: "to investigate", english: "untersuchen, nachgehen", example: "The police investigated the murder case.", box: 1 },
            { german: "beneficial", english: "nÃ¼tzlich, vorteilhaft", example: "It is sometimes beneficial to include a diagram when trying to explain something.", box: 1 },
            { german: "to be in demand", english: "gefragt sein", example: "Shortly after the pandemic, face masks started to be in demand.", box: 1 },
            { german: "to omit", english: "auÃŸer Acht lassen, auslassen, unterlassen", example: "I will omit any information I find unnecessary.", box: 1 },
            { german: "pamphlet", english: "(kleine) BroschÃ¼re, Faltblatt, Pamphlet", example: "Can you help me design a short pamphlet for my German class?", box: 1 },
            { german: "plus", english: "darÃ¼ber hinaus, zusÃ¤tzlich, auÃŸerdem", example: "I'm not very good at sports. Plus, I have recently sprained my ankle.", box: 1 },
            { german: "fellow", english: "Mit..., ...genosse/genossin, Kollege/Kollegin", example: "My fellow colleagues also complained about their work.", box: 1 },
            { german: "fruitful", english: "fruchtbar, ertragreich, hier: lohnend", example: "My year abroad turned out to be very fruitful.", box: 1 },
            { german: "to flounder", english: "stolpern, strampeln, sich abmÃ¼hen", example: "During the speech, the mayor suddenly started to flounder.", box: 1 },
            { german: "to graduate", english: "einen (UniversitÃ¤ts)abschluss erwerben", example: "I want to graduate with a good grade.", box: 1 }
        ];

        // Die Haupt-Vokabelliste
        let VOCABULARY_BASE = [];
        
        const TEST_VOCABULARY_COUNT = 15; 
        let testQuestions = []; 
        let testResults = []; 
        
        // Train View Variables
        // **cards ist jetzt ein Array von Vokabeln, die heute trainiert werden sollen**
        let cards = []; 
        // **currentCard ist der Index im cards-Array**
        let currentCardIndex = 0;
        let correctAnswersCount = 0; 
        let initialDeckSize = 0;
        // **NEU: Speichert die gerade aktive Vokabel aus VOCABULARY_BASE**
        let activeVocab = null;
        // **NEU: Speichert Details der Vokabeln wÃ¤hrend des Trainings**
        let trainingSessionDetails = []; 
        // **NEU: Speichert die Boxen, die trainiert werden sollen (Standard: Box 1)**
        let selectedTrainingBoxes = [1]; 
        // **NEU: Daten-Inversion (falls DEFAULT_VOCABULARY versehentlich vertauschte Felder enthÃ¤lt)**
        let dataInverted = false;

        // Card direction: 'de->en' shows German and expects English (default)
        const DIRECTION_KEY = 'vokabeltrainer_v19_direction';
        let cardDirection = 'de->en';

        // Games View Variables (UnverÃ¤ndert)
        let matchCardsData = [];
        let selectedMatchCard = null;
        let matchesFound = 0;
        
        let hangmanWord = '';
        let hangmanHint = '';
        let guessedLetters = [];
        let mistakes = 0;
        const maxMistakes = 6;
        
        let quizQuestions = [];
        let quizCurrentQuestionIndex = 0;
        let quizScore = 0;
        const QUIZ_COUNT = 10;
        
        let fibQuestions = [];
        let fibCurrentQuestionIndex = 0;
        let fibScore = 0;
        const FIB_COUNT = 10;
        
        
        // --- SPEICHERFUNKTIONEN ---
        const STORAGE_KEY = 'vokabeltrainer_v19_vocab';
        // **NEU: Speichert die Auswahl der Boxen fÃ¼r das Training**
        const SELECTED_BOXES_KEY = 'vokabeltrainer_v19_selected_boxes';
        // Progress tracking key
        const PROGRESS_KEY = 'vokabeltrainer_v19_progress';
        const TRAINING_SESSIONS_KEY = 'vokabeltrainer_v19_sessions';
        const LAST_TRAINED_KEY = 'vokabeltrainer_v19_last_trained';
        // **NEU: Detailliertes Trainings-Log mit Zeitstempel und Ergebnissen**
        const TRAINING_LOG_KEY = 'vokabeltrainer_v19_training_log';
        // **NEU: Speichert geplante Tests im Kalender**
        const SCHEDULED_TESTS_KEY = 'vokabeltrainer_v19_scheduled_tests';
        
        // **ENTFERNT: BOX_TRAIN_DATE_KEY - DIESE KONSTANTE WIRD NICHT MEHR BENÃ–TIGT.**

        function loadVocabulary() {
            try {
                const storedVocab = localStorage.getItem(STORAGE_KEY);
                if (storedVocab) {
                    VOCABULARY_BASE = JSON.parse(storedVocab);
                    
                    // **NEU: FÃ¼ge 'box: 1' zu Vokabeln hinzu, die noch keine Box haben (fÃ¼r Ã¤ltere SpeicherstÃ¤nde)**
                    VOCABULARY_BASE.forEach(v => {
                        if (typeof v.box !== 'number' || v.box < 1 || v.box > NUM_BOXES) {
                            v.box = 1; 
                        }
                    });
                    
                } else {
                    // Beim ersten Start die Standard-Vokabeln laden und speichern
                    VOCABULARY_BASE = DEFAULT_VOCABULARY;
                    saveVocabulary();
                }
                
                // **NEU: Geladene Box-Auswahl**
                const storedBoxes = localStorage.getItem(SELECTED_BOXES_KEY);
                if (storedBoxes) {
                    selectedTrainingBoxes = JSON.parse(storedBoxes);
                }
                
                // PrÃ¼fe, ob die Daten invertiert vorliegen (z.B. german/english Felder vertauscht)
                try { detectDataInversion(); } catch(e) { console.error('Fehler bei dataInversion check:', e); }
                
            } catch (e) {
                console.error("Fehler beim Laden der Vokabeln aus Local Storage:", e);
                // Fallback zu Standard-Vokabeln
                VOCABULARY_BASE = DEFAULT_VOCABULARY;
            }
        }

        // PrÃ¼ft, ob die geladenen Vokabelobjekte versehentlich vertauschte Felder haben
        function detectDataInversion() {
            try {
                if (!VOCABULARY_BASE || VOCABULARY_BASE.length === 0) return;
                const sample = VOCABULARY_BASE.slice(0, Math.min(10, VOCABULARY_BASE.length));
                let germanHasUmlaut = 0;
                let englishHasUmlaut = 0;
                sample.forEach(v => {
                    if (!v) return;
                    try {
                        if (/[Ã¤Ã¶Ã¼ÃŸÃ„Ã–Ãœ]/.test(String(v.german))) germanHasUmlaut++;
                        if (/[Ã¤Ã¶Ã¼ÃŸÃ„Ã–Ãœ]/.test(String(v.english))) englishHasUmlaut++;
                    } catch (e) {}
                });
                // Wenn mehr deutsche Zeichen im englisch-Feld vorkommen, ist wahrscheinlich invertiert
                dataInverted = englishHasUmlaut > germanHasUmlaut;
                if (dataInverted) console.info('DATA INVERSION detected: german/english fields appear swapped');
            } catch (e) {
                console.error('Fehler bei der Erkennung invertierter Daten:', e);
            }
        }

        function saveVocabulary() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(VOCABULARY_BASE));
                console.log(`Vokabeln gespeichert. Gesamtanzahl: ${VOCABULARY_BASE.length}`);
            } catch (e) {
                console.error("Fehler beim Speichern der Vokabeln in Local Storage:", e);
            }
        }
        
        // **NEU: Speichern der Box-Auswahl**
        function saveSelectedBoxes() {
             localStorage.setItem(SELECTED_BOXES_KEY, JSON.stringify(selectedTrainingBoxes));
        }

        // Save/load card direction
        function saveCardDirection() {
            try { localStorage.setItem(DIRECTION_KEY, cardDirection); } catch(e) { console.error('Fehler beim Speichern der Richtung:', e); }
        }
        function loadCardDirection() {
            try {
                const stored = localStorage.getItem(DIRECTION_KEY);
                if (stored === 'en->de' || stored === 'de->en') {
                    cardDirection = stored;
                }
                if (directionSelect) directionSelect.value = cardDirection;
            } catch(e) { console.error('Fehler beim Laden der Richtung:', e); }
        }

        function updateDirectionUI() {
            if (directionSelect) directionSelect.value = cardDirection;
            if (cardDirection === 'de->en') {
                answerInput.placeholder = 'Englische Antwort';
                if (activeVocab) {
                    frontTextElement.textContent = activeVocab.german;
                    backTextElement.textContent = activeVocab.english;
                    feedbackElement.textContent = 'Gib die englische Ãœbersetzung ein.';
                }
            } else {
                answerInput.placeholder = 'Deutsche Antwort';
                if (activeVocab) {
                    frontTextElement.textContent = activeVocab.english;
                    backTextElement.textContent = activeVocab.german;
                    feedbackElement.textContent = 'Gib die deutsche Ãœbersetzung ein.';
                }
            }
        }

        // **ENTFERNT: setBoxTrainedDate() - DIESE FUNKTION WIRD NICHT MEHR BENÃ–TIGT.**
        // **ENTFERNT: hasBoxBeenTrainedToday() - DIESE FUNKTION WIRD NICHT MEHR BENÃ–TIGT.**


        // ----------------------------------------------------------------------
        // 2. DOM Elements
        // ----------------------------------------------------------------------
        
        const cardElement = document.getElementById('flashcard');
        const frontTextElement = document.getElementById('cardFront').querySelector('p');
        const backTextElement = document.getElementById('cardBack').querySelector('p');
        const answerInput = document.getElementById('answerInput');
        const checkButton = document.getElementById('checkButton');
        const startButton = document.getElementById('startButton');
        const showAnswerButton = document.getElementById('showAnswerButton');
        const nextActions = document.getElementById('nextActions');
        const feedbackElement = document.getElementById('feedback');
        const currentCardIndexElement = document.getElementById('currentCardIndex');
        const totalCardsElement = document.getElementById('totalCards');
        const progressBar = document.getElementById('progressBar');
        const vocabularyListBody = document.getElementById('vocabularyListBody');
        const listTotalCountElement = document.getElementById('listTotalCount');
        const testContainer = document.getElementById('test-container');
        const testResultsContainer = document.getElementById('test-results');
        const testInfoElement = document.getElementById('test-info');
        const testQuestionsContainer = document.getElementById('test-questions');
        const submitTestButton = document.getElementById('submitTestButton');
        const startTestButton = document.getElementById('startTestButton');
        const resultCorrectElement = document.getElementById('result-correct');
        const resultIncorrectElement = document.getElementById('result-incorrect');
        const resultGradeElement = document.getElementById('result-grade');
        const testCorrectionContainer = document.getElementById('test-correction');
        const imageUpload = document.getElementById('imageUpload');
        const scanButton = document.getElementById('scanButton');
        const imagePreview = document.getElementById('image-preview');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const addStatus = document.getElementById('add-status');
        const extractedListContainer = document.getElementById('extracted-list-container');
        const extractedList = document.getElementById('extracted-list');
        const extractedCount = document.getElementById('extractedCount');
        // **NEU: Box Stats Element fÃ¼r Train View**
        const boxStatsElement = document.getElementById('box-stats'); 
        // **NEU: Box Stats Element fÃ¼r Home View**
        const boxStatsHomeElement = document.getElementById('box-stats-home');
        // **NEU: Box Selection Container fÃ¼r Train View**
        const boxSelectionContainer = document.getElementById('box-selection-container');
        // Direction select in Train View
        const directionSelect = document.getElementById('directionSelect');
        // **NEU: List Filter Info fÃ¼r List View**
        const listFilterInfo = document.getElementById('list-filter-info');
        
        // NEUE MANAGE ELEMENTE
        const germanInput = document.getElementById('germanInput');
        const englishInput = document.getElementById('englishInput');
        const exampleInput = document.getElementById('exampleInput');
        const manualStatus = document.getElementById('manual-status');

        // Games View Elements (UnverÃ¤ndert)
        const matchItContainer = document.getElementById('match-it-container');
        const matchCardsContainer = document.getElementById('match-cards');
        const matchStatus = document.getElementById('match-status');
        const hangmanContainer = document.getElementById('hangman-container');
        const hangmanGerman = document.getElementById('hangman-german');
        const hangmanWordElement = document.getElementById('hangman-word');
        const hangmanMistakes = document.getElementById('hangman-mistakes');
        const hangmanKeyboard = document.getElementById('hangman-keyboard');
        const hangmanStatus = document.getElementById('hangman-status');
        const quizTimeContainer = document.getElementById('quiz-time-container');
        const quizGermanTerm = document.getElementById('quizGermanTerm');
        const quizOptionsContainer = document.getElementById('quizOptions');
        const quizCurrentQuestionElement = document.getElementById('quizCurrentQuestion');
        const quizStatus = document.getElementById('quizStatus');
        const quizNextButton = document.getElementById('quizNextButton');
        const quizResultsContainer = document.getElementById('quizResults');
        const quizScoreElement = document.getElementById('quizScore');

        const fillInBlankContainer = document.getElementById('fill-in-blank-container');
        const fibCurrentQuestionElement = document.getElementById('fibCurrentQuestion');
        const fibGermanTerm = document.getElementById('fibGermanTerm');
        const fibSentence = document.getElementById('fibSentence');
        const fibAnswerInput = document.getElementById('fibAnswerInput');
        const fibCheckButton = document.getElementById('fibCheckButton');
        const fibNextButton = document.getElementById('fibNextButton');
        const fibStatus = document.getElementById('fibStatus');
        const fibResultsContainer = document.getElementById('fibResults');
        const fibScoreElement = document.getElementById('fibScore');


        // ----------------------------------------------------------------------
        // 3. Helper Functions (UnverÃ¤ndert)
        // ----------------------------------------------------------------------

        // Direction select handler setup (if element exists)
        if (typeof directionSelect !== 'undefined' && directionSelect) {
            directionSelect.onchange = function(e) {
                cardDirection = e.target.value;
                saveCardDirection();
                updateDirectionUI();
            };
        }


        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function normalizeAnswer(answer) {
            answer = answer.toLowerCase();
            answer = answer.replace(/\([^)]*\)/g, '').trim(); 
            answer = answer.replace(/[^a-zÃ¤Ã¶Ã¼ÃŸ/\s']/g, ''); 
            return answer.replace(/\s+/g, ' ').trim();
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => {
                    const base64String = reader.result.split(',')[1]; 
                    resolve(base64String);
                };
                reader.onerror = error => reject(error);
            });
        }
        
        // ----------------------------------------------------------------------
        // 4. Navigation Logic
        // ----------------------------------------------------------------------

        window.showView = function(viewId, filterBox = null) {
            document.querySelectorAll('.view').forEach(view => {
                view.classList.add('hidden');
            });

            const activeView = document.getElementById(viewId + '-view');
            if (activeView) {
                activeView.classList.remove('hidden');
            }

            // Spezifische Initialisierung
            if (viewId === 'home') {
                 // **NEU: Render Box Stats fÃ¼r die Home-Seite**
                renderBoxStatsHome();
                // **NEU: Render Progress Chart**
                renderProgressChart();
                // **NEU: Update Streak Display**
                updateStreakDisplay();
                // **NEU: Render Testplan-Kalender auf der Home-Seite**
                renderTestCalendar();
                updateCalendarCountdown();
                document.getElementById('calendarStreakDisplay').textContent = document.getElementById('streak-display').textContent;
            } else if (viewId === 'settings') {
                // **NEU: Update Settings Stats beim Ã–ffnen**
                updateSettingsStats();
            } else if (viewId === 'list') {
                // **FilterBox-Parameter an renderVocabularyList Ã¼bergeben**
                renderVocabularyList(filterBox);
            } else if (viewId === 'train') {
                // **NEU: Box-Statistiken rendern und Box-Auswahl rendern**
                renderBoxStats();
                renderBoxSelection();
                
                totalCardsElement.textContent = VOCABULARY_BASE.length;
                currentCardIndexElement.textContent = correctAnswersCount;
                if (cards.length === 0) {
                    frontTextElement.textContent = 'Klicke auf START';
                    backTextElement.textContent = '';
                    startButton.classList.remove('hidden');
                    checkButton.classList.add('hidden');
                    showAnswerButton.classList.add('hidden'); 
                    nextActions.classList.add('hidden');
                    answerInput.disabled = true;
                    cardElement.classList.remove('flipped'); 
                    const baseProgress = initialDeckSize > 0 ? (correctAnswersCount / initialDeckSize) * 100 : 0;
                    progressBar.style.width = `${baseProgress}%`;
                }
            } else if (viewId === 'test') {
                testContainer.classList.remove('hidden');
                testResultsContainer.classList.add('hidden');
                startTestButton.classList.remove('hidden');
                submitTestButton.classList.add('hidden');
                testQuestionsContainer.innerHTML = '';
                testInfoElement.textContent = `Bereit fÃ¼r den Test? Es werden ${TEST_VOCABULARY_COUNT} zufÃ¤llige Vokabeln abgefragt.`;
            } else if (viewId === 'manage') { 
                imagePreviewContainer.classList.add('hidden');
                extractedListContainer.classList.add('hidden');
                addStatus.innerHTML = '';
                manualStatus.innerHTML = '';
                germanInput.value = '';
                englishInput.value = '';
                exampleInput.value = '';

                if (imageUpload.files.length > 0) {
                    scanButton.disabled = false;
                    const file = imageUpload.files[0];
                     const reader = new FileReader();
                     reader.onload = (e) => {
                         imagePreview.src = e.target.result;
                         imagePreviewContainer.classList.remove('hidden');
                     };
                     reader.readAsDataURL(file);
                } else {
                    scanButton.disabled = true;
                }
            } else if (viewId === 'games') {
                 matchItContainer.classList.add('hidden');
                 hangmanContainer.classList.add('hidden');
                 quizTimeContainer.classList.add('hidden');
                 fillInBlankContainer.classList.add('hidden'); 
                 
                 document.querySelectorAll('#games-view button[id^="start-"]').forEach(btn => btn.disabled = false);
            }

             // Hervorheben des aktiven Navigations-Buttons
             document.querySelectorAll('.nav-button').forEach(button => {
                const isCurrentView = button.onclick.toString().includes(`showView('${viewId}')`);
                
                button.classList.remove('bg-blue-200', 'hover:bg-blue-300', 'bg-red-200', 'hover:bg-red-300', 'bg-teal-200', 'hover:bg-teal-300', 'bg-orange-200', 'hover:bg-orange-300', 'bg-indigo-200', 'hover:bg-indigo-300');
                button.classList.add('bg-gray-200', 'hover:bg-gray-300');

                if (isCurrentView) {
                    let baseClass = 'gray';
                    if (viewId === 'train') baseClass = 'blue';
                    else if (viewId === 'test') baseClass = 'red';
                    // Der Nav-Button fÃ¼r Manage ist der gleiche wie der Home-Button
                    else if (viewId === 'list') baseClass = 'indigo';
                    else if (viewId === 'games') baseClass = 'orange';
                    else if (viewId === 'home') baseClass = 'gray'; // Home ist der Standard-Grauton
                    
                    button.classList.replace('bg-gray-200', `bg-${baseClass}-200`);
                    button.classList.replace('hover:bg-gray-300', `hover:bg-${baseClass}-300`);
                }
            });
        }
        
        // Event-Listener fÃ¼r das Bild-Upload-Feld
        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreviewContainer.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
                scanButton.disabled = false;
            } else {
                imagePreviewContainer.classList.add('hidden');
                scanButton.disabled = true;
            }
            extractedListContainer.classList.add('hidden');
            addStatus.innerHTML = '';
        });
        
        // **NEUE FUNKTION: Wechselt zur Listenansicht und filtert nach Kasten**
        window.showBoxVocabularyList = function(boxNumber) {
             showView('list', boxNumber);
        }

        // ----------------------------------------------------------------------
        // 5. MANUELLE HINZUFÃœGUNG Logik
        // ----------------------------------------------------------------------

        window.addManualVocabulary = function() {
            const german = germanInput.value.trim();
            const english = englishInput.value.trim();
            const example = exampleInput.value.trim();

            if (!german || !english) {
                manualStatus.innerHTML = '<span class="text-red-500">âŒ Bitte fÃ¼llen Sie das Deutsch- und das Englischfeld aus.</span>';
                return;
            }

            const newCard = {
                german: german,
                english: english,
                example: example || `You need to learn the English word for "${german}". The correct word is [VOCAB].`,
                // **NEU: Neue Vokabeln starten in Box 1**
                box: 1 
            };

            // Vokabelliste aktualisieren
            addNewVocabulary([newCard]);

            // UI zurÃ¼cksetzen
            manualStatus.innerHTML = '<span class="text-green-600">âœ… Vokabel erfolgreich hinzugefÃ¼gt!</span>';
            germanInput.value = '';
            englishInput.value = '';
            exampleInput.value = '';
            germanInput.focus();

            // Nach 2 Sekunden Status-Meldung zurÃ¼cksetzen
            setTimeout(() => manualStatus.innerHTML = '', 2000);
        }

        // ----------------------------------------------------------------------
        // 6. KI-Logik (Manage View) - UnverÃ¤ndert
        // ----------------------------------------------------------------------
        const VOCABULARY_SCHEMA = {
            type: "ARRAY",
            description: "Eine Liste von Vokabelpaaren, extrahiert aus dem Bild. Jedes Element sollte die deutsche Vokabel und deren englische Ãœbersetzung enthalten.",
            items: {
                type: "OBJECT",
                properties: {
                    "german": {
                        "type": "STRING",
                        "description": "Die Vokabel in deutscher Sprache."
                    },
                    "english": {
                        "type": "STRING",
                        "description": "Die Vokabel in englischer Sprache."
                    }
                },
                required: ["german", "english"]
            }
        };
        
        window.extractVocabularyFromImage = async function() {
            const file = imageUpload.files[0];
            if (!file) { addStatus.innerHTML = '<span class="text-red-500">âŒ Bitte wÃ¤hlen Sie zuerst ein Bild aus.</span>'; return; }

            scanButton.disabled = true;
            addStatus.innerHTML = '<div class="loading-indicator"></div><span class="ml-2 text-blue-600 font-medium">Scanne Bild und extrahiere Vokabeln...</span>';
            extractedListContainer.classList.add('hidden');

            try {
                const base64ImageData = await fileToBase64(file);
                const mimeType = file.type;

                // **GEMINI API INTEGRATION**
                // API Key wird von window.GEMINI_API_KEY gelesen (siehe unten bei Initialisierung)
                if (!window.GEMINI_API_KEY || window.GEMINI_API_KEY === 'HIER_IHREN_API_KEY_EINSETZEN') {
                    throw new Error('Gemini API Key nicht gesetzt. Bitte setzen Sie window.GEMINI_API_KEY in der Datei.');
                }

                const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + window.GEMINI_API_KEY;

                const requestBody = {
                    contents: [{
                        parts: [
                            {
                                text: 'Extrahiere alle Vokabelpaare aus diesem Bild. Das Bild zeigt Deutsche und Englische Vokabeln nebeneinander oder untereinander (z.B. "to adjust" / "einstellen"). Antworte NUR mit folgendem JSON-Format, KEINE anderen Texte: {"vocabularies": [{"german": "...", "english": "..."}, ...]}. Wenn das Bild keine klaren Vokabelpaare zeigt, antworte: {"vocabularies": []}.'
                            },
                            {
                                inlineData: {
                                    mimeType: mimeType,
                                    data: base64ImageData
                                }
                            }
                        ]
                    }]
                };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Gemini API Fehler: ${response.status} - ${errorData.error?.message || 'Unbekannter Fehler'}`);
                }

                const result = await response.json();
                const content = result.candidates?.[0]?.content?.parts?.[0]?.text || '';

                // Parse JSON aus Antwort (robuste Variante)
                let extractedVocabs = [];
                try {
                    // Versuche zuerst direktes JSON-Parsing
                    try {
                        const parsed = JSON.parse(content);
                        extractedVocabs = parsed.vocabularies || [];
                    } catch (directParseError) {
                        // Falls direktes Parsing fehlschlÃ¤gt, versuche JSON-Extraktion mit besserem Regex
                        const jsonMatch = content.match(/\{[\s\S]*"vocabularies"[\s\S]*\}/);
                        if (jsonMatch) {
                            const parsed = JSON.parse(jsonMatch[0]);
                            extractedVocabs = parsed.vocabularies || [];
                        } else {
                            throw new Error('Konnte JSON-Format in Antwort nicht finden. Antwort: ' + content.substring(0, 200));
                        }
                    }
                } catch (parseError) {
                    console.error('JSON Parse Error:', parseError, 'Response:', content);
                    throw new Error('Konnte Antwort nicht verarbeiten. Stellen Sie sicher, dass das Bild klare Vokabelpaare zeigt.');
                }

                if (extractedVocabs.length === 0) {
                    addStatus.innerHTML = '<span class="text-yellow-600 font-medium">âš ï¸ Keine Vokabeln im Bild gefunden.</span>';
                    renderExtractedList([]);
                } else {
                    addStatus.innerHTML = `<span class="text-blue-600 font-medium">ğŸ“ ${extractedVocabs.length} Vokabeln gefunden. ÃœberprÃ¼fen und bearbeiten Sie diese unten:</span>`;
                    renderExtractedList(extractedVocabs);
                    renderEditableExtractedList(extractedVocabs);
                }

            } catch (error) {
                console.error("Fehler beim Extrahieren der Vokabeln:", error);
                let errorMessage = error.message;
                addStatus.innerHTML = `<span class="text-red-500 font-medium">âŒ Fehler: ${errorMessage}. Bitte versuchen Sie es erneut.</span>`;
            } finally {
                scanButton.disabled = false;
            }
        }

        function addNewVocabulary(newCards) {
            if (Array.isArray(newCards)) {
                const validNewCards = newCards.filter(card => 
                    card.german && card.english && card.german.trim() !== '' && card.english.trim() !== ''
                );
                // Beispiel-Satz hinzufÃ¼gen, falls nicht vorhanden (fÃ¼r Fill-in-Blank)
                validNewCards.forEach(card => {
                    if (!card.example) {
                        card.example = `You need to learn the English word for "${card.german}". The correct word is [VOCAB].`;
                    }
                    // **NEU: Setze neue Vokabeln in Box 1**
                    if (typeof card.box !== 'number') {
                         card.box = 1; 
                    }
                });
                VOCABULARY_BASE = VOCABULARY_BASE.concat(validNewCards);
                saveVocabulary(); // WICHTIG: Nach jeder Ã„nderung speichern
                initialDeckSize = VOCABULARY_BASE.length; // Wichtig: GrÃ¶ÃŸe aktualisieren
                // **NEU: Box-Statistiken aktualisieren**
                renderBoxStats(); 
                renderBoxStatsHome();
            }
        }

        function renderExtractedList(list) {
            extractedList.innerHTML = '';
            extractedCount.textContent = list.length;
            extractedListContainer.classList.remove('hidden');

            list.forEach((card, index) => {
                const item = document.createElement('div');
                item.classList.add('flex', 'justify-between', 'items-center', 'p-3', 'bg-white', 'rounded-md', 'shadow-sm', 'border-l-4', 'border-teal-400');
                item.innerHTML = `
                    <div class="text-sm">
                        <p class="font-semibold text-gray-800">${card.german}</p>
                        <p class="text-gray-600 italic">${card.english}</p>
                    </div>
                    <span class="text-xs text-teal-600 font-bold">NEU (Box 1)</span>
                `;
                extractedList.appendChild(item);
            });
            
            if (list.length === 0) {
                 extractedList.innerHTML = '<p class="text-center text-gray-500 p-4">Es wurden keine gÃ¼ltigen Vokabelpaare gefunden.</p>';
            }
        }

        // Editable preview for extracted vocabularies
        let pendingVocabularies = [];
        function renderEditableExtractedList(list) {
            pendingVocabularies = JSON.parse(JSON.stringify(list));
            const container = document.getElementById('editable-extracted-container');
            if (!container) return;

            container.innerHTML = '';
            const heading = document.createElement('h4');
            heading.className = 'text-lg font-bold text-gray-800 mb-3';
            heading.textContent = 'âœï¸ Vokabeln anpassen & Ã¼berprÃ¼fen:';
            container.appendChild(heading);

            pendingVocabularies.forEach((card, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'p-3 bg-gray-50 rounded-lg border border-gray-300 mb-2';
                itemDiv.innerHTML = `
                    <div class="flex gap-2 mb-2">
                        <div class="flex-1">
                            <label class="text-xs font-semibold text-gray-700">Deutsch:</label>
                            <input type="text" class="w-full p-1 border rounded text-sm" value="${card.german}" id="edit-de-${index}">
                        </div>
                        <div class="flex-1">
                            <label class="text-xs font-semibold text-gray-700">Englisch:</label>
                            <input type="text" class="w-full p-1 border rounded text-sm" value="${card.english}" id="edit-en-${index}">
                        </div>
                    </div>
                    <div class="flex gap-1">
                        <button class="flex-1 bg-red-400 hover:bg-red-500 text-white text-xs font-bold py-1 rounded" onclick="removeEditableVocab(${index})">âŒ LÃ¶schen</button>
                    </div>
                `;
                container.appendChild(itemDiv);
            });

            const buttonDiv = document.createElement('div');
            buttonDiv.className = 'mt-4 flex gap-2';
            buttonDiv.innerHTML = `
                <button class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 rounded-lg" onclick="confirmAndAddVocabularies()">âœ… Alle hinzufÃ¼gen</button>
                <button class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 rounded-lg" onclick="cancelExtraction()">âŒ Abbrechen</button>
            `;
            container.appendChild(buttonDiv);
        }

        window.removeEditableVocab = function(index) {
            pendingVocabularies.splice(index, 1);
            renderEditableExtractedList(pendingVocabularies);
        }

        window.confirmAndAddVocabularies = function() {
            const container = document.getElementById('editable-extracted-container');
            if (!container) return;

            // Collect edited values
            const updatedVocabs = [];
            pendingVocabularies.forEach((card, index) => {
                const deInput = document.getElementById(`edit-de-${index}`);
                const enInput = document.getElementById(`edit-en-${index}`);
                if (deInput && enInput) {
                    updatedVocabs.push({
                        german: deInput.value.trim(),
                        english: enInput.value.trim()
                    });
                }
            });

            // Add to vocabulary
            addNewVocabulary(updatedVocabs);
            
            // Clear UI
            imageUpload.value = '';
            imagePreviewContainer.classList.add('hidden');
            extractedListContainer.classList.add('hidden');
            container.innerHTML = '';
            addStatus.innerHTML = `<span class="text-green-600 font-medium">âœ… ${updatedVocabs.length} Vokabeln erfolgreich hinzugefÃ¼gt!</span>`;
            setTimeout(() => addStatus.innerHTML = '', 3000);
            
            pendingVocabularies = [];
        }

        window.cancelExtraction = function() {
            imageUpload.value = '';
            imagePreviewContainer.classList.add('hidden');
            extractedListContainer.classList.add('hidden');
            const container = document.getElementById('editable-extracted-container');
            if (container) container.innerHTML = '';
            addStatus.innerHTML = '';
            pendingVocabularies = [];
        }
        
        // ----------------------------------------------------------------------
        // 7. List View Logic (inkl. LÃ¶schen und Filtern)
        // ----------------------------------------------------------------------
        // **Ã„NDERUNG: Akzeptiert optional eine Box-Nummer zum Filtern**
        function renderVocabularyList(filterBox = null) {
            vocabularyListBody.innerHTML = '';
            
            let filteredVocab = [...VOCABULARY_BASE];
            
            if (filterBox !== null && filterBox !== 'all') {
                 filteredVocab = VOCABULARY_BASE.filter(v => v.box === filterBox);
                 listFilterInfo.textContent = `Vokabeln in Kasten ${filterBox} (insgesamt: ${filteredVocab.length})`;
            } else {
                 listFilterInfo.textContent = `Alle Vokabeln werden angezeigt (insgesamt: ${VOCABULARY_BASE.length})`;
            }
            
            filteredVocab.sort((a, b) => (dataInverted ? a.english.localeCompare(b.english) : a.german.localeCompare(b.german)));
            
            filteredVocab.forEach((card, index) => {
                const row = vocabularyListBody.insertRow();
                row.classList.add('hover:bg-gray-50', 'transition-colors');
                
                // Bestimme Deutsch und Englisch basierend auf dataInverted
                const germanText = dataInverted ? card.english : card.german;
                const englishText = dataInverted ? card.german : card.english;
                
                let cellGerman = row.insertCell();
                cellGerman.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-sm', 'font-medium', 'text-gray-900');
                cellGerman.textContent = germanText;
                
                let cellEnglish = row.insertCell();
                cellEnglish.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-sm', 'text-gray-500');
                cellEnglish.textContent = englishText;
                
                // **NEU: Box-Spalte**
                let cellBox = row.insertCell();
                cellBox.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-center', 'text-sm', 'font-bold');
                cellBox.textContent = `Box ${card.box}`;
                
                let cellAction = row.insertCell();
                cellAction.classList.add('px-6', 'py-4', 'whitespace-nowrap', 'text-right', 'text-sm', 'font-medium', 'space-x-2');
                
                // Edit-Button
                const editButton = document.createElement('button');
                editButton.textContent = 'âœï¸ Bearbeiten';
                editButton.classList.add('text-blue-600', 'hover:text-blue-900', 'transition-colors', 'font-bold', 'mr-2');
                editButton.onclick = () => openEditVocabModal(card);
                cellAction.appendChild(editButton);
                
                // Delete-Button
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'ğŸ—‘ï¸ LÃ¶schen';
                deleteButton.classList.add('text-red-600', 'hover:text-red-900', 'transition-colors', 'font-bold');
                deleteButton.onclick = () => deleteVocabularyItem(card);
                cellAction.appendChild(deleteButton);
            });
            
            listTotalCountElement.textContent = VOCABULARY_BASE.length;
            
            // Suchfeld Setup
            const searchInput = document.getElementById('vocabularySearchInput');
            if (searchInput) {
                searchInput.value = ''; // Suchfeld leeren
                searchInput.onkeyup = filterVocabularyList;
            }
        }
        
        // **NEUE FUNKTION: Filtert die Vokabelliste basierend auf Suchtext**
        function filterVocabularyList() {
            const searchText = document.getElementById('vocabularySearchInput').value.toLowerCase();
            const rows = document.querySelectorAll('#vocabularyListBody tr');
            let visibleCount = 0;
            
            rows.forEach(row => {
                const germanCell = row.cells[0].textContent.toLowerCase();
                const englishCell = row.cells[1].textContent.toLowerCase();
                
                // Zeige die Reihe nur, wenn der Suchtext in Deutsch oder Englisch vorkommt
                if (germanCell.includes(searchText) || englishCell.includes(searchText)) {
                    row.style.display = '';
                    visibleCount++;
                } else {
                    row.style.display = 'none';
                }
            });
            
            // Aktualisiere die Anzeige
            if (searchText === '') {
                listFilterInfo.textContent = `Alle Vokabeln werden angezeigt (insgesamt: ${VOCABULARY_BASE.length})`;
            } else {
                listFilterInfo.textContent = `Suchergebnis: ${visibleCount} von ${VOCABULARY_BASE.length} Vokabeln gefunden`;
            }
        }
        
        window.deleteVocabularyItem = function(vocabToDelete) {
            // BestÃ¤tigung abfragen
            if (!confirm(`Soll die Vokabel "${vocabToDelete.german}" wirklich gelÃ¶scht werden?`)) {
                return;
            }

            // Finde den Index dieser Vokabel im VOCABULARY_BASE
            const actualIndex = VOCABULARY_BASE.findIndex(v => v.german === vocabToDelete.german && v.english === vocabToDelete.english);
            
            if (actualIndex > -1) {
                VOCABULARY_BASE.splice(actualIndex, 1);
                saveVocabulary(); // Speichern
                // **Ã„NDERUNG: Ruft renderVocabularyList ohne Filter auf, um die Gesamtansicht neu zu laden**
                renderVocabularyList(); 
                renderBoxStats(); 
                renderBoxStatsHome();
            }
        }

        // ----------------------------------------------------------------------
        // 8. Train View Logic (MIT KASTENSYSTEM & AUSWAHL)
        // ----------------------------------------------------------------------
        
        // **NEUE FUNKTION: Rendert die Checkboxen fÃ¼r die Kasten-Auswahl**
        function renderBoxSelection() {
            boxSelectionContainer.innerHTML = '';
            for (let i = 1; i <= NUM_BOXES; i++) {
                const boxDiv = document.createElement('div');
                boxDiv.classList.add('flex', 'items-center', 'space-x-1');
                
                const boxCheckbox = document.createElement('input');
                boxCheckbox.type = 'checkbox';
                boxCheckbox.id = `box-select-${i}`;
                boxCheckbox.value = i;
                boxCheckbox.classList.add('h-4', 'w-4', 'text-blue-600', 'border-gray-300', 'rounded', 'focus:ring-blue-500');
                boxCheckbox.checked = selectedTrainingBoxes.includes(i);
                boxCheckbox.onchange = () => handleBoxSelectionChange(i, boxCheckbox.checked);
                
                const boxLabel = document.createElement('label');
                boxLabel.htmlFor = `box-select-${i}`;
                boxLabel.textContent = `Box ${i}`;
                boxLabel.classList.add('text-sm', 'font-medium', 'text-gray-700');
                
                boxDiv.appendChild(boxCheckbox);
                boxDiv.appendChild(boxLabel);
                boxSelectionContainer.appendChild(boxDiv);
            }
        }
        
        // **NEUE FUNKTION: Behandelt die Ã„nderung der Kasten-Auswahl**
        window.handleBoxSelectionChange = function(boxNumber, isChecked) {
             if (isChecked) {
                 if (!selectedTrainingBoxes.includes(boxNumber)) {
                     selectedTrainingBoxes.push(boxNumber);
                 }
             } else {
                 selectedTrainingBoxes = selectedTrainingBoxes.filter(box => box !== boxNumber);
                 // Stelle sicher, dass mindestens eine Box ausgewÃ¤hlt ist (optional)
                 if (selectedTrainingBoxes.length === 0) {
                     selectedTrainingBoxes = [1];
                     // Setze die Box 1 Checkbox wieder auf checked, um Konsistenz zu gewÃ¤hrleisten
                     document.getElementById('box-select-1').checked = true;
                     // Optional: Feedback geben
                     alert('Mindestens eine Box muss fÃ¼r das Training ausgewÃ¤hlt sein. Box 1 wurde automatisch ausgewÃ¤hlt.');
                 }
             }
             saveSelectedBoxes();
             renderBoxStats(); // Update die Box-Stats im Train-View
        }
        
        // **REPARIERTE FUNKTION: Jede Box kann jederzeit trainiert werden - KEINE WARTEZEIT**
        window.getCardsForTraining = function() { // **FIX: Funktion global definieren (window.)**
            if (selectedTrainingBoxes.length === 0) {
                 return [];
            }
            
            // Einfacher Filter: Nur die ausgewÃ¤hlten Boxen, KEINE zeitlichen EinschrÃ¤nkungen
            const cardsToReview = VOCABULARY_BASE.filter(v => {
                const box = v.box || 1;
                return selectedTrainingBoxes.includes(box);
            });
            
            // Mische alle Karten und gib sie zurÃ¼ck
            return shuffleArray(cardsToReview);
        }
        
        // **NEUE FUNKTION: Rendert die Box-Statistiken auf der Home-Seite**
        function renderBoxStatsHome() {
            const boxCounts = {};
            for (let i = 1; i <= NUM_BOXES; i++) {
                boxCounts[i] = VOCABULARY_BASE.filter(v => v.box === i).length;
            }
            
            boxStatsHomeElement.innerHTML = '';

            const boxDescriptions = {
                1: "ğŸ”´ Noch nicht gelernt",
                2: "ğŸŸ¡ AnfÃ¤nger",
                3: "ğŸŸ  Fortgeschritten",
                4: "ğŸŸ¢ Sehr gut",
                5: "â­ Mastered"
            };

            for (let i = 1; i <= NUM_BOXES; i++) {
                let colorClass = 'bg-gray-200';
                let borderColor = 'border-gray-400';
                if (i === 1) { colorClass = 'bg-red-100'; borderColor = 'border-red-400'; }
                else if (i === NUM_BOXES) { colorClass = 'bg-green-100'; borderColor = 'border-green-400'; }
                else if (i === 2) { colorClass = 'bg-yellow-100'; borderColor = 'border-yellow-400'; }
                else if (i === 3) { colorClass = 'bg-orange-100'; borderColor = 'border-orange-400'; }
                else if (i === 4) { colorClass = 'bg-blue-100'; borderColor = 'border-blue-400'; }


                const cardHtml = `
                    <div class="p-4 ${colorClass} rounded-xl shadow-md border-2 ${borderColor} cursor-pointer hover:shadow-lg transition-shadow duration-150" 
                         onclick="showBoxVocabularyList(${i})">
                        <div class="flex justify-between items-center">
                            <div>
                                <h3 class="text-xl font-bold text-gray-800">Kasten ${i}</h3>
                                <p class="text-sm text-gray-600 mt-1">${boxDescriptions[i]}</p>
                            </div>
                            <span class="text-3xl font-extrabold text-gray-900">${boxCounts[i]}</span>
                        </div>
                    </div>
                `;
                boxStatsHomeElement.innerHTML += cardHtml;
            }
        }
        
        // **GEÃ„NDERTE FUNKTION: Rendert die Box-Statistiken im Train-View**
        function renderBoxStats() {
            const boxCounts = {};
            for (let i = 1; i <= NUM_BOXES; i++) {
                boxCounts[i] = 0;
            }
            
            VOCABULARY_BASE.forEach(v => {
                const box = v.box || 1;
                if (box >= 1 && box <= NUM_BOXES) {
                    boxCounts[box]++;
                }
            });
            
            let html = '';
            for (let i = 1; i <= NUM_BOXES; i++) {
                // Farben und Beschriftung fÃ¼r die Boxen
                let colorClass = 'bg-gray-300';
                if (i === 1) colorClass = 'bg-red-400 text-white';
                else if (i === NUM_BOXES) colorClass = 'bg-green-500 text-white';
                else colorClass = 'bg-yellow-400';
                
                // **NEU: Hebe ausgewÃ¤hlte Boxen hervor**
                const isSelected = selectedTrainingBoxes.includes(i);
                const selectionClass = isSelected ? 'ring-4 ring-offset-1 ring-blue-500/50' : '';
                
                html += `<div title="${isSelected ? 'FÃ¼r Training ausgewÃ¤hlt' : 'Nicht ausgewÃ¤hlt'}" class="py-1 px-3 rounded-full font-bold ${colorClass} ${selectionClass}">Box ${i}: ${boxCounts[i]}</div>`;
            }
            
            boxStatsElement.innerHTML = `<div class="flex flex-wrap justify-center gap-2">${html}</div>`;
        }


        window.handleCardClick = function() {
            if (cards.length > 0) {
                if (nextActions.classList.contains('hidden')) {
                    cardElement.classList.toggle('flipped');
                    
                    if (!cardElement.classList.contains('flipped')) {
                        const dir = (directionSelect && directionSelect.value) ? directionSelect.value : cardDirection;
                        feedbackElement.textContent = (dir === 'de->en') ? 'Gib die englische Ãœbersetzung ein.' : 'Gib die deutsche Ãœbersetzung ein.';
                        answerInput.disabled = false;
                        checkButton.disabled = false;
                        answerInput.focus();
                    } else {
                        feedbackElement.innerHTML = '<span class="text-blue-600 font-bold">Die Antwort ist aufgedeckt. WÃ¤hle den Status:</span>';
                        checkButton.disabled = true;
                        answerInput.disabled = true;
                        showAnswerButton.classList.remove('hidden'); 
                        nextActions.classList.remove('hidden'); 
                    }

                } else {
                    cardElement.classList.toggle('flipped');
                    if (cardElement.classList.contains('flipped')) {
                        feedbackElement.innerHTML = '<span class="text-blue-600 font-bold">Die Antwort ist aufgedeckt. WÃ¤hle den Status:</span>';
                    } else {
                        feedbackElement.innerHTML = '<span class="text-blue-600 font-bold">Sieh dir die Vokabel nochmal an. WÃ¤hle den Status:</span>';
                    }
                }
            }
        }

        window.startTrainGame = function() { 
            // ==================================================================
            // HIER IST DIE REPARATUR:
            // Die Funktion `getCardsForTraining` wurde als `window.getCardsForTraining`
            // definiert, daher muss sie auch mit `window.` aufgerufen werden,
            // um 100% sicherzustellen, dass sie gefunden wird.
            // ==================================================================
            cards = window.getCardsForTraining(); 
            activeVocab = null; // Aktuelle Karte zurÃ¼cksetzen

            if (cards.length === 0) {
                // **NEU: Angepasste Meldung basierend auf der Auswahl**
                const totalSelected = VOCABULARY_BASE.filter(v => selectedTrainingBoxes.includes(v.box || 1)).length;
                
                if (totalSelected === 0) {
                     frontTextElement.textContent = 'Bitte fÃ¼ge Vokabeln hinzu oder wÃ¤hle Boxen aus.';
                } else {
                     // **REPARATUR: Angepasste Meldung, da Wartezeit entfernt wurde.**
                     frontTextElement.textContent = 'Keine fÃ¤lligen Vokabeln in den ausgewÃ¤hlten Boxen! Alle fÃ¤lligen Boxen wurden bereits trainiert.';
                }

                backTextElement.textContent = '';
                startButton.classList.remove('hidden');
                checkButton.classList.add('hidden');
                showAnswerButton.classList.add('hidden');
                nextActions.classList.add('hidden');
                answerInput.disabled = true;
                return;
            }

            currentCardIndex = 0;
            correctAnswersCount = 0;
            initialDeckSize = cards.length;
            trainingSessionDetails = []; // **NEU: Reset fÃ¼r neues Training**
            
            // **REPARATUR: Entfernung der Logik zur Markierung von Box 1 als trainiert.**
            // if (cards.some(v => v.box === 1)) {
            //     setBoxTrainedDate();
            // }

            startButton.classList.add('hidden');
            checkButton.classList.remove('hidden');
            showAnswerButton.classList.remove('hidden');
            nextActions.classList.add('hidden');
            feedbackElement.textContent = '';
            answerInput.value = '';
            answerInput.disabled = false;
            answerInput.focus();
            cardElement.classList.remove('flipped');
            
            // Beenden-Button anzeigen
            document.getElementById('cancelTrainButton').classList.remove('hidden');
            
            // Box-Auswahl wÃ¤hrend des Trainings deaktivieren
            boxSelectionContainer.querySelectorAll('input').forEach(input => input.disabled = true);
            
            renderBoxStats(); // Box-Statistiken aktualisieren
            loadCard();
        }
        
        // **NEUE FUNKTION: Bricht das aktuelle Training ab und setzt alles zurÃ¼ck**
        window.cancelTraining = function() {
            // Speichere die Trainings-Session wenn mindestens eine Vokabel beantwortet wurde
            if (trainingSessionDetails.length > 0) {
                recordTrainingSession('normal', trainingSessionDetails);
            }
            
            // Trainings-Zustand zurÃ¼cksetzen
            cards = [];
            currentCardIndex = 0;
            correctAnswersCount = 0;
            initialDeckSize = 0;
            activeVocab = null;
            trainingSessionDetails = []; // **NEU: Reset Details**
            
            // UI-Elemente zurÃ¼cksetzen
            cardElement.classList.remove('flipped');
            frontTextElement.textContent = 'Klicke auf START';
            backTextElement.textContent = '';
            feedbackElement.textContent = '';
            answerInput.value = '';
            answerInput.disabled = true;
            checkButton.disabled = true;
            showAnswerButton.classList.add('hidden');
            nextActions.classList.add('hidden');
            
            // Progress-Anzeige zurÃ¼cksetzen
            progressBar.style.width = '0%';
            currentCardIndexElement.textContent = '0';
            totalCardsElement.textContent = '0';
            
            // Start-Button anzeigen, Beenden-Button verbergen
            startButton.classList.remove('hidden');
            document.getElementById('cancelTrainButton').classList.add('hidden');
            
            // Box-Auswahl wieder aktivieren
            boxSelectionContainer.querySelectorAll('input').forEach(input => input.disabled = false);
            
            // Box-Statistiken aktualisieren
            renderBoxStats();
        }
        
        // NEUE HELFERFUNKTION: Setzt die Karte sofort zurÃ¼ck, um die nÃ¤chste Vokabel zu verdecken
        function resetCardDisplay() {
            cardElement.classList.remove('flipped'); // Stellt sicher, dass die Karte vorne ist
            frontTextElement.textContent = 'NÃ¤chste Vokabel wird geladen...'; // Verdeckt den nÃ¤chsten Begriff
            backTextElement.textContent = ''; // Verdeckt die Antwort
            
            answerInput.value = '';
            answerInput.disabled = true;
            checkButton.disabled = true;
            showAnswerButton.classList.add('hidden'); 
            nextActions.classList.add('hidden');
            feedbackElement.textContent = '';
        }

        function loadCard() {
            if (currentCardIndex >= cards.length) {
                endGame();
                return;
            }

            activeVocab = cards[currentCardIndex]; // **NEU: Setze activeVocab**
            
            currentCardIndexElement.textContent = correctAnswersCount;
            totalCardsElement.textContent = initialDeckSize;
            // Fortschrittsbalken zeigt jetzt nur korrekt beantwortete Vokabeln an
            progressBar.style.width = `${(initialDeckSize > 0 ? (correctAnswersCount / initialDeckSize) * 100 : 0)}%`; 

            // VerzÃ¶gertes Setzen des Textes:
            setTimeout(() => {
                // Verwende die aktuell ausgewÃ¤hlte Richtung aus dem Select (Fallback auf cardDirection)
                const dir = (directionSelect && directionSelect.value) ? directionSelect.value : cardDirection;

                // Wenn die eingelesenen Daten vertauscht sind (dataInverted), dann sind
                // 'german' und 'english' Felder in den Objekten vertauscht.
                // Wir passen Anzeige und Platzhalter entsprechend an.
                if (dir === 'de->en') {
                    if (!dataInverted) {
                        frontTextElement.textContent = activeVocab.german;
                        backTextElement.textContent = activeVocab.english;
                    } else {
                        // Daten sind invertiert: english enthÃ¤lt das deutsche Wort
                        frontTextElement.textContent = activeVocab.english;
                        backTextElement.textContent = activeVocab.german;
                    }
                    answerInput.placeholder = 'Englische Antwort';
                    feedbackElement.textContent = 'Gib die englische Ãœbersetzung ein.';
                } else {
                    if (!dataInverted) {
                        frontTextElement.textContent = activeVocab.english;
                        backTextElement.textContent = activeVocab.german;
                    } else {
                        frontTextElement.textContent = activeVocab.german;
                        backTextElement.textContent = activeVocab.english;
                    }
                    answerInput.placeholder = 'Deutsche Antwort';
                    feedbackElement.textContent = 'Gib die deutsche Ãœbersetzung ein.';
                }

                answerInput.disabled = false;
                checkButton.disabled = false;
                showAnswerButton.classList.remove('hidden'); 
                nextActions.classList.add('hidden');
                answerInput.focus();
            }, 100); // 100ms VerzÃ¶gerung, um das "Laden" zu simulieren und das Verraten zu verhindern
        }

        window.checkAnswer = function() {
            if (!activeVocab) return;
            
            const userAnswer = normalizeAnswer(answerInput.value);
            // Verwende die aktuell ausgewÃ¤hlte Richtung aus dem Select (Fallback auf cardDirection)
            const dir = (directionSelect && directionSelect.value) ? directionSelect.value : cardDirection;
            // Bestimme die korrekte Antwort unter BerÃ¼cksichtigung mÃ¶glicher Daten-Inversion
            let correctAnswerRaw;
            if (dir === 'de->en') {
                correctAnswerRaw = dataInverted ? activeVocab.german : activeVocab.english;
            } else {
                correctAnswerRaw = dataInverted ? activeVocab.english : activeVocab.german;
            }
            const correctAnswer = normalizeAnswer(correctAnswerRaw);

            if (userAnswer === '') {
                feedbackElement.textContent = 'Bitte gib eine Antwort ein.';
                return;
            }

            checkButton.disabled = true;
            answerInput.disabled = true;
            showAnswerButton.classList.add('hidden');
            
            cardElement.classList.add('flipped'); 

            if (userAnswer === correctAnswer) {
                feedbackElement.innerHTML = '<span class="text-green-600 font-bold">âœ… Korrekt! Gut gemacht.</span>';
            } else {
                feedbackElement.innerHTML = '<span class="text-red-600 font-bold">âŒ Falsch. Vergleiche deine Antwort mit der richtigen:</span>';
            }
            
            nextActions.classList.remove('hidden');
        }
        
        // **Ã„NDERUNG: Diese Funktion implementiert die Kastensystem-Logik**
        window.processResult = function(isCorrect) {
            if (!activeVocab) return;
            
            // **NEU: Session-Details erfassen**
            trainingSessionDetails.push({
                german: activeVocab.german,
                english: activeVocab.english,
                isCorrect: isCorrect,
                userAnswer: answerInput.value || '(Ãœbersprungen)'
            });
            
            const vocabInBase = VOCABULARY_BASE.find(v => v.german === activeVocab.german && v.english === activeVocab.english);
            
            if (vocabInBase) {
                if (isCorrect) {
                    // **Korrekt: Vokabel in die nÃ¤chste Box verschieben (max. Box 5)**
                    vocabInBase.box = Math.min(vocabInBase.box + 1, NUM_BOXES);
                    correctAnswersCount++; // ZÃ¤hlt als erfolgreich trainiert
                } else {
                    // **Falsch: Vokabel zurÃ¼ck in Box 1 verschieben**
                    vocabInBase.box = 1;
                }
                
                // **WICHTIG: Speichern, da sich der Box-Status im VOCABULARY_BASE geÃ¤ndert hat.**
                saveVocabulary(); 
                renderBoxStats(); // Box-Statistiken aktualisieren
                renderBoxStatsHome(); // Home-Statistiken aktualisieren
            }

            currentCardIndex++;
            
            // **WICHTIG: Verhindere das Anzeigen des neuen deutschen Wortes**
            resetCardDisplay(); 

            // Nach einer kurzen VerzÃ¶gerung die nÃ¤chste Karte laden
            setTimeout(loadCard, 100); 
        }

        function endGame() {
            const totalVocabs = initialDeckSize; 
            const currentScore = correctAnswersCount; 
            
            frontTextElement.textContent = 'Training abgeschlossen!';
            backTextElement.textContent = `Ergebnis: ${currentScore} von ${totalVocabs} fÃ¤lligen Vokabeln erfolgreich trainiert.`;
            
            feedbackElement.innerHTML = `<span class="text-blue-600 font-bold">Alle fÃ¤lligen Vokabeln fÃ¼r heute in den ausgewÃ¤hlten Boxen trainiert.</span>`;

            cardElement.classList.remove('flipped');
            startButton.classList.remove('hidden');
            checkButton.classList.add('hidden');
            showAnswerButton.classList.add('hidden');
            nextActions.classList.add('hidden');
            answerInput.disabled = true;
            
            // Box-Auswahl nach Ende des Trainings wieder aktivieren
            boxSelectionContainer.querySelectorAll('input').forEach(input => input.disabled = false);
            
            progressBar.style.width = '100%';
            currentCardIndexElement.textContent = currentScore;
            
            // **NEU: Trainings-Session mit Details aufzeichnen**
            recordTrainingSession('normal', trainingSessionDetails);
            
            // Beenden-Button verbergen
            document.getElementById('cancelTrainButton').classList.add('hidden');
            
            renderBoxStats(); 
        }
        
        // ----------------------------------------------------------------------
        // 9. Test View Logic
        // ----------------------------------------------------------------------
        let testDirection = 'de->en';
        
        window.startTest = function() {
            if (VOCABULARY_BASE.length < TEST_VOCABULARY_COUNT) {
                testInfoElement.textContent = `Du benÃ¶tigst mindestens ${TEST_VOCABULARY_COUNT} Vokabeln, um den Test zu starten. Aktuell: ${VOCABULARY_BASE.length}`;
                return;
            }

            // Hole die Richtung aus dem Select-Element
            const directionSelect = document.getElementById('testDirectionSelect');
            if (directionSelect) {
                testDirection = directionSelect.value;
            }

            testQuestionsContainer.innerHTML = '';
            testResultsContainer.classList.add('hidden');
            
            const shuffledVocab = shuffleArray([...VOCABULARY_BASE]);
            testQuestions = shuffledVocab.slice(0, TEST_VOCABULARY_COUNT).map(v => ({
                vocab: v,
                userAnswer: '',
                isCorrect: false
            }));
            
            testQuestions.forEach((q, index) => {
                let prompt, answerLabel;
                
                if (testDirection === 'de->en') {
                    // Frage: Deutsch, Antwort: Englisch
                    prompt = dataInverted ? q.vocab.english : q.vocab.german;
                    answerLabel = 'Englische Ãœbersetzung:';
                } else {
                    // Frage: Englisch, Antwort: Deutsch
                    prompt = dataInverted ? q.vocab.german : q.vocab.english;
                    answerLabel = 'Deutsche Ãœbersetzung:';
                }
                
                const questionHtml = `
                    <div id="test-q-${index}" class="test-question-item p-4 border-l-4 border-gray-400 bg-white rounded-lg shadow">
                        <p class="text-sm font-semibold text-gray-700 mb-2">Frage ${index + 1}:</p>
                        <p class="text-xl font-bold text-gray-900 mb-3">${prompt}</p>
                        <label for="answer-${index}" class="block text-sm font-medium text-gray-500 mb-1">${answerLabel}</label>
                        <input type="text" id="answer-${index}" data-index="${index}" placeholder="Deine Antwort eingeben..." class="p-2 border border-gray-300 rounded-lg w-full focus:outline-none focus:ring-2 focus:ring-red-500 test-input" onchange="updateTestAnswer(${index}, this.value)">
                        <div id="correction-${index}" class="mt-2 text-sm text-red-600 font-medium hidden"></div>
                    </div>
                `;
                testQuestionsContainer.innerHTML += questionHtml;
            });

            testInfoElement.textContent = `Du machst den Test mit ${TEST_VOCABULARY_COUNT} Vokabeln. Viel Erfolg!`;
            startTestButton.classList.add('hidden');
            submitTestButton.classList.remove('hidden');
        }

        window.updateTestAnswer = function(index, value) {
            if (testQuestions[index]) {
                testQuestions[index].userAnswer = value;
            }
        }

        window.submitTest = function() {
            testResults = testQuestions.map((q, index) => {
                const userAnswer = normalizeAnswer(q.userAnswer);
                
                // Bestimme die korrekte Antwort basierend auf testDirection
                let correctAnswerRaw;
                if (testDirection === 'de->en') {
                    // Antwort sollte Englisch sein
                    correctAnswerRaw = dataInverted ? q.vocab.german : q.vocab.english;
                } else {
                    // Antwort sollte Deutsch sein
                    correctAnswerRaw = dataInverted ? q.vocab.english : q.vocab.german;
                }
                
                const correctAnswer = normalizeAnswer(correctAnswerRaw);
                const isCorrect = userAnswer === correctAnswer;
                
                const item = document.getElementById(`test-q-${index}`);
                item.setAttribute('data-status', isCorrect ? 'correct' : (q.userAnswer.trim() === '' ? 'skipped' : 'incorrect'));

                return {
                    ...q,
                    userAnswer: q.userAnswer,
                    correctAnswer: correctAnswerRaw,
                    isCorrect: isCorrect,
                    status: isCorrect ? 'correct' : (q.userAnswer.trim() === '' ? 'skipped' : 'incorrect')
                };
            });
            
            // **NEU: Vokabeln in Boxen verschieben basierend auf Test-Ergebnisse**
            testResults.forEach(result => {
                const vocabInBase = VOCABULARY_BASE.find(v => v.german === result.vocab.german && v.english === result.vocab.english);
                if (vocabInBase) {
                    if (result.isCorrect) {
                        // Korrekt: in nÃ¤chste Box verschieben
                        vocabInBase.box = Math.min(vocabInBase.box + 1, NUM_BOXES);
                    } else {
                        // Falsch: zurÃ¼ck in Box 1
                        vocabInBase.box = 1;
                    }
                }
            });
            // Speichere die geÃ¤nderten Vokabeln
            saveVocabulary();
            
            testContainer.classList.add('hidden');
            testResultsContainer.classList.remove('hidden');
            
            renderEditableCorrection();
            recalculateTestScore();
            
            // **NEU: Speichere Test als Trainings-Session mit Note**
            const correctCount = testResults.filter(r => r.isCorrect).length;
            const sessionDetails = testResults.map(r => ({
                german: r.vocab.german,
                english: r.vocab.english,
                isCorrect: r.isCorrect,
                userAnswer: r.userAnswer || '(Ãœbersprungen)'
            }));
            
            // Berechne die Note
            const totalQuestions = testResults.length;
            const percentage = totalQuestions > 0 ? (correctCount / totalQuestions) : 0;
            let grade;
            if (percentage >= 0.92) grade = '1+'; 
            else if (percentage >= 0.85) grade = '1'; 
            else if (percentage >= 0.80) grade = '1-';
            else if (percentage >= 0.75) grade = '2+'; 
            else if (percentage >= 0.67) grade = '2'; 
            else if (percentage >= 0.60) grade = '2-'; 
            else if (percentage >= 0.55) grade = '3+'; 
            else if (percentage >= 0.50) grade = '3'; 
            else if (percentage >= 0.45) grade = '3-'; 
            else if (percentage >= 0.40) grade = '4+'; 
            else if (percentage >= 0.33) grade = '4'; 
            else if (percentage >= 0.25) grade = '4-'; 
            else if (percentage >= 0.15) grade = '5'; 
            else grade = '6';
            
            // Speichere Session und setze die Note
            recordTrainingSession('test', sessionDetails);
            
            // FÃ¼ge die Note zum letzten Log-Eintrag hinzu
            try {
                let log = JSON.parse(localStorage.getItem(TRAINING_LOG_KEY) || '[]');
                if (log.length > 0) {
                    log[log.length - 1].grade = grade;
                    localStorage.setItem(TRAINING_LOG_KEY, JSON.stringify(log));
                }
            } catch (e) {
                console.error('Fehler beim Speichern der Note:', e);
            }
        }

        window.setCorrectionStatus = function(index, newStatus) {
            const question = testResults[index];
            if (!question) return;

            question.isCorrect = newStatus;
            
            const statusElement = document.getElementById(`correction-status-${index}`);
            
            if (newStatus) {
                statusElement.textContent = 'âœ… Korrekt (Manuell)';
                statusElement.classList.remove('text-red-600');
                statusElement.classList.add('text-green-600');
            } else {
                statusElement.textContent = 'âŒ Falsch (Manuell)';
                statusElement.classList.remove('text-green-600');
                statusElement.classList.add('text-red-600');
            }

            recalculateTestScore();
            
            // **NEU: Aktualisiere Boxen und Trainingslog nach manueller Ã„nderung**
            updateTestResultsInBoxes();
            updateTrainingLogWithNewTestResults();
        }
        
        // **NEU: Verschiebe Vokabeln in Boxen basierend auf den (mÃ¶glicherweise geÃ¤nderten) Test-Ergebnissen**
        function updateTestResultsInBoxes() {
            testResults.forEach(result => {
                const vocabInBase = VOCABULARY_BASE.find(v => v.german === result.vocab.german && v.english === result.vocab.english);
                if (vocabInBase) {
                    if (result.isCorrect) {
                        // Korrekt: in nÃ¤chste Box verschieben
                        vocabInBase.box = Math.min(vocabInBase.box + 1, NUM_BOXES);
                    } else {
                        // Falsch: zurÃ¼ck in Box 1
                        vocabInBase.box = 1;
                    }
                }
            });
            // Speichere die geÃ¤nderten Vokabeln
            saveVocabulary();
        }
        
        // **NEU: Aktualisiere das Trainingslog mit neuen Test-Ergebnissen nach manueller Ã„nderung**
        function updateTrainingLogWithNewTestResults() {
            try {
                let log = JSON.parse(localStorage.getItem(TRAINING_LOG_KEY) || '[]');
                if (log.length === 0) return;
                
                // Finde den letzten Test-Eintrag
                const lastEntry = log[log.length - 1];
                if (lastEntry.type !== 'test') return;
                
                // Berechne neue Werte basierend auf testResults
                const correctCount = testResults.filter(r => r.isCorrect).length;
                const totalCount = testResults.length;
                
                // Aktualisiere den Log-Eintrag
                lastEntry.correct = correctCount;
                lastEntry.total = totalCount;
                lastEntry.successRate = totalCount > 0 ? ((correctCount / totalCount) * 100).toFixed(1) : '0';
                lastEntry.details = testResults.map(r => ({
                    german: r.vocab.german,
                    english: r.vocab.english,
                    isCorrect: r.isCorrect,
                    userAnswer: r.userAnswer || '(Ãœbersprungen)'
                }));
                
                // Berechne die neue Note
                const percentage = totalCount > 0 ? (correctCount / totalCount) : 0;
                let grade;
                if (percentage >= 0.92) grade = '1+'; 
                else if (percentage >= 0.85) grade = '1'; 
                else if (percentage >= 0.80) grade = '1-';
                else if (percentage >= 0.75) grade = '2+'; 
                else if (percentage >= 0.67) grade = '2'; 
                else if (percentage >= 0.60) grade = '2-'; 
                else if (percentage >= 0.55) grade = '3+'; 
                else if (percentage >= 0.50) grade = '3'; 
                else if (percentage >= 0.45) grade = '3-'; 
                else if (percentage >= 0.40) grade = '4+'; 
                else if (percentage >= 0.33) grade = '4'; 
                else if (percentage >= 0.25) grade = '4-'; 
                else if (percentage >= 0.15) grade = '5'; 
                else grade = '6';
                
                lastEntry.grade = grade;
                
                // Speichere das aktualisierte Log
                localStorage.setItem(TRAINING_LOG_KEY, JSON.stringify(log));
                
                // Aktualisiere die Anzeige
                renderTrainingLog();
            } catch (e) {
                console.error('Fehler beim Aktualisieren des Trainings-Logs:', e);
            }
        }

        function renderEditableCorrection() {
            testCorrectionContainer.innerHTML = '';
            
            testResults.forEach((q, index) => {
                const isSkipped = q.userAnswer.trim() === '';
                const statusClass = q.isCorrect ? 'border-green-500 bg-green-50' : (isSkipped ? 'border-yellow-500 bg-yellow-50' : 'border-red-500 bg-red-50');
                const statusText = q.isCorrect ? 'âœ… Korrekt' : (isSkipped ? 'âš ï¸ Ãœbersprungen' : 'âŒ Falsch');
                const statusColor = q.isCorrect ? 'text-green-600' : 'text-red-600';

                const itemHtml = `
                    <div class="p-4 rounded-lg shadow-md border-l-4 ${statusClass}">
                        <p class="text-sm font-medium text-gray-700">Frage ${index + 1}: <span class="text-lg font-bold">${testDirection === 'de->en' ? (dataInverted ? q.vocab.english : q.vocab.german) : (dataInverted ? q.vocab.german : q.vocab.english)}</span></p>
                        <p class="text-xs text-gray-500 mt-1">Erwartet: <span class="font-bold text-gray-800">${q.correctAnswer}</span></p>
                        <p class="text-xs text-gray-500">Deine Eingabe: <span class="font-bold text-gray-800">${q.userAnswer || '-- Leer --'}</span></p>
                        
                        <div class="mt-3 pt-3 border-t border-gray-200 flex justify-between items-center">
                            <p id="correction-status-${index}" class="text-sm font-bold ${statusColor}">${statusText}</p>
                            <div class="space-x-2">
                                <button class="bg-green-200 hover:bg-green-300 text-green-800 text-xs font-bold py-1 px-3 rounded-full" onclick="setCorrectionStatus(${index}, true)">
                                    Richtig setzen
                                </button>
                                <button class="bg-red-200 hover:bg-red-300 text-red-800 text-xs font-bold py-1 px-3 rounded-full" onclick="setCorrectionStatus(${index}, false)">
                                    Falsch setzen
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                testCorrectionContainer.innerHTML += itemHtml;
            });
        }

        window.recalculateTestScore = function() {
            const totalQuestions = testResults.length;
            if (totalQuestions === 0) return;
            
            const correctCount = testResults.filter(q => q.isCorrect).length;
            const incorrectCount = totalQuestions - correctCount;
            const percentage = (correctCount / totalQuestions);
            
            let grade;
            if (percentage >= 0.92) grade = '1+'; 
            else if (percentage >= 0.85) grade = '1'; 
            else if (percentage >= 0.80) grade = '1-';
            else if (percentage >= 0.75) grade = '2+'; 
            else if (percentage >= 0.67) grade = '2'; 
            else if (percentage >= 0.60) grade = '2-'; 
            else if (percentage >= 0.55) grade = '3+'; 
            else if (percentage >= 0.50) grade = '3'; 
            else if (percentage >= 0.45) grade = '3-'; 
            else if (percentage >= 0.40) grade = '4+'; 
            else if (percentage >= 0.33) grade = '4'; 
            else if (percentage >= 0.25) grade = '4-'; 
            else if (percentage >= 0.15) grade = '5'; 
            else grade = '6'; 

            resultCorrectElement.textContent = correctCount;
            resultIncorrectElement.textContent = incorrectCount;
            resultGradeElement.textContent = grade;
            
            let gradeColor = 'red';
            if (percentage >= 0.85) gradeColor = 'green';
            else if (percentage >= 0.50) gradeColor = 'yellow';
            else if (percentage >= 0.33) gradeColor = 'orange';

            testResultsContainer.classList.remove('border-red-500', 'border-green-500', 'border-yellow-500', 'border-orange-500');
            testResultsContainer.classList.add(`border-${gradeColor}-500`);
            testResultsContainer.classList.remove('bg-red-50', 'bg-green-50', 'bg-yellow-50', 'bg-orange-50');
            testResultsContainer.classList.add(`bg-${gradeColor}-50`);
            
            resultGradeElement.classList.remove('text-red-900', 'text-green-900', 'text-yellow-900', 'text-orange-900');
            resultGradeElement.classList.add(`text-${gradeColor}-900`);
        }
        
        // ----------------------------------------------------------------------
        // 10. Games View Logic (UnverÃ¤ndert, aber die Daten sind jetzt korrekt)
        // ----------------------------------------------------------------------

        window.startGame = function(gameType) {
             matchItContainer.classList.add('hidden');
             hangmanContainer.classList.add('hidden');
             quizTimeContainer.classList.add('hidden'); 
             fillInBlankContainer.classList.add('hidden'); 
             
             document.querySelectorAll('#games-view button[id^="start-"]').forEach(btn => {
                 btn.disabled = false;
             });
             const startButton = document.getElementById(`start-${gameType}`);
             if (startButton) {
                 startButton.disabled = true;
             }
             
             if (gameType === 'match-it') {
                 matchItContainer.classList.remove('hidden');
                 initMatchItGame();
             } else if (gameType === 'hangman') {
                 hangmanContainer.classList.remove('hidden');
                 initHangmanGame();
             } else if (gameType === 'quiz-time') { 
                 quizTimeContainer.classList.remove('hidden');
                 initQuizTimeGame();
             } else if (gameType === 'fill-in-blank') { 
                 fillInBlankContainer.classList.remove('hidden');
                 initFillInBlankGame();
             }
        }
        
        // --- Match It! Game (Zuordnungsspiel) ---
        function initMatchItGame() {
            if (VOCABULARY_BASE.length < 4) {
                matchStatus.innerHTML = '<span class="text-red-600">âŒ FÃ¼ge mindestens 4 Vokabeln hinzu, um das Spiel zu spielen!</span>';
                document.getElementById('start-match-it').disabled = false;
                return;
            }

            matchCardsContainer.innerHTML = '';
            matchStatus.textContent = 'Finde die passenden Paare!';
            selectedMatchCard = null;
            matchesFound = 0;
            
            const subset = shuffleArray([...VOCABULARY_BASE]).slice(0, 4);
            matchCardsData = [];
            
            subset.forEach((vocab, index) => {
                // Deutsche Karte
                matchCardsData.push({ id: index, term: vocab.german, type: 'german' }); 
                // Englische Karte
                matchCardsData.push({ id: index, term: vocab.english, type: 'english' }); 
            });

            matchCardsData = shuffleArray(matchCardsData);
            
            matchCardsData.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.classList.add('match-card', card.type === 'german' ? 'match-card-german' : 'match-card-english');
                cardElement.textContent = card.term;
                cardElement.dataset.id = card.id;
                cardElement.dataset.index = index;
                cardElement.onclick = () => handleMatchCardClick(cardElement, card.id, index);
                matchCardsContainer.appendChild(cardElement);
            });
        }

        function handleMatchCardClick(element, id, index) {
            if (element.classList.contains('matched')) return;

            if (selectedMatchCard) {
                if (selectedMatchCard.index === index) {
                    element.classList.remove('selected');
                    selectedMatchCard = null;
                    return;
                }
                
                element.classList.add('selected');

                if (selectedMatchCard.id === id) {
                    matchesFound++;
                    matchStatus.innerHTML = `<span class="text-green-600 font-bold">ğŸ‰ Match gefunden! (${matchesFound}/4)</span>`;
                    
                    document.querySelectorAll(`.match-card[data-id="${id}"]`).forEach(card => {
                        card.classList.remove('selected');
                        card.classList.add('matched');
                    });
                    
                    if (matchesFound === 4) {
                        matchStatus.innerHTML = '<span class="text-green-800 font-bold text-lg">ğŸ† GEWONNEN! Alle Paare gefunden!</span>';
                        document.getElementById('start-match-it').disabled = false;
                    }
                } else {
                    matchStatus.innerHTML = '<span class="text-red-600 font-bold">âŒ Kein Match. Versuch es nochmal.</span>';
                    
                    setTimeout(() => {
                        element.classList.remove('selected');
                        document.querySelector(`.match-card[data-index="${selectedMatchCard.index}"]`).classList.remove('selected');
                    }, 500);
                }
                selectedMatchCard = null;
                
            } else {
                element.classList.add('selected');
                selectedMatchCard = { id: id, index: index };
                matchStatus.textContent = 'WÃ¤hle die passende Ãœbersetzung...';
            }
        }


        // --- Hangman Game (Galgenraten) ---
        const KEYBOARD = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        function initHangmanGame() {
            if (VOCABULARY_BASE.length === 0) {
                hangmanStatus.innerHTML = '<span class="text-red-600">âŒ Bitte fÃ¼ge Vokabeln hinzu, um Hangman zu spielen!</span>';
                document.getElementById('start-hangman').disabled = false;
                return;
            }
            
            hangmanStatus.textContent = '';
            mistakes = 0;
            guessedLetters = [];
            hangmanMistakes.textContent = mistakes;
            
            const randomVocab = shuffleArray([...VOCABULARY_BASE])[0];
            // Hinweis ist Deutsch
            hangmanHint = randomVocab.german; 
            // Zu erratendes Wort ist Englisch
            hangmanWord = normalizeAnswer(randomVocab.english); 
            
            hangmanGerman.textContent = hangmanHint;
            
            renderHangmanWord();
            renderHangmanKeyboard();
        }

        function renderHangmanWord() {
            hangmanWordElement.innerHTML = '';
            let isWordGuessed = true;
            
            for (const char of hangmanWord) {
                const span = document.createElement('span');
                
                if (KEYBOARD.includes(char.toUpperCase()) && !guessedLetters.includes(char.toLowerCase())) {
                    span.textContent = '';
                    isWordGuessed = false;
                } else if (char === ' ') {
                    span.textContent = '/';
                    span.style.borderBottom = 'none';
                } else if (char === "'") {
                    span.textContent = "'"; 
                    span.style.borderBottom = 'none';
                } else {
                    span.textContent = char.toUpperCase();
                }
                hangmanWordElement.appendChild(span);
            }
            
            if (isWordGuessed && hangmanWord.length > 0) {
                endHangmanGame(true);
            }
        }

        function renderHangmanKeyboard() {
            hangmanKeyboard.innerHTML = '';
            for (const char of KEYBOARD) {
                const button = document.createElement('button');
                button.textContent = char;
                button.classList.add('bg-indigo-300', 'hover:bg-indigo-400', 'text-indigo-900');
                
                if (guessedLetters.includes(char.toLowerCase())) {
                    button.disabled = true;
                    if (hangmanWord.includes(char.toLowerCase())) {
                        button.classList.remove('bg-indigo-300', 'hover:bg-indigo-400');
                        button.classList.add('bg-green-400');
                    } else {
                        button.classList.remove('bg-indigo-300', 'hover:bg-indigo-400');
                        button.classList.add('bg-red-400');
                    }
                } else {
                    button.onclick = () => handleHangmanGuess(char.toLowerCase(), button);
                }
                
                hangmanKeyboard.appendChild(button);
            }
        }

        window.handleHangmanGuess = function(letter, button) {
            if (guessedLetters.includes(letter)) return;
            
            guessedLetters.push(letter);
            button.disabled = true;

            if (hangmanWord.includes(letter)) {
                button.classList.remove('bg-indigo-300', 'hover:bg-indigo-400');
                button.classList.add('bg-green-400');
                renderHangmanWord();
                hangmanStatus.textContent = 'Toll! Richtig geraten.';
            } else {
                button.classList.remove('bg-indigo-300', 'hover:bg-indigo-400');
                button.classList.add('bg-red-400');
                mistakes++;
                hangmanMistakes.textContent = mistakes;
                hangmanStatus.textContent = 'Falsch. Ein Versuch weniger.';
            }
            
            if (mistakes >= maxMistakes) {
                endHangmanGame(false);
            }
        }

        function endHangmanGame(won) {
            if (won) {
                hangmanStatus.innerHTML = '<span class="text-green-800 font-bold text-lg">ğŸ† GEWONNEN! Du hast das Wort erraten!</span>';
            } else {
                hangmanStatus.innerHTML = `<span class="text-red-800 font-bold text-lg">ğŸ’€ VERLOREN! Das Wort war: ${hangmanWord.toUpperCase()}</span>`;
            }
            
            hangmanKeyboard.querySelectorAll('button').forEach(btn => btn.disabled = true);
            document.getElementById('start-hangman').disabled = false;
        }
        
        // --- Quiz Time! Game (Multiple Choice) ---

        function initQuizTimeGame() {
            if (VOCABULARY_BASE.length < 4) {
                quizStatus.innerHTML = '<span class="text-red-600">âŒ FÃ¼ge mindestens 4 Vokabeln hinzu, um das Quiz zu spielen!</span>';
                document.getElementById('start-quiz-time').disabled = false;
                return;
            }
            
            quizResultsContainer.classList.add('hidden');
            quizNextButton.classList.add('hidden');
            quizCurrentQuestionIndex = 0;
            quizScore = 0;

            quizQuestions = shuffleArray([...VOCABULARY_BASE]);
            quizQuestions = quizQuestions.slice(0, QUIZ_COUNT); 
            
            quizQuestions.forEach(q => q.options = generateQuizOptions(q));
            
            loadNextQuizQuestion();
        }

        function generateQuizOptions(correctVocab) {
            const allIncorrect = VOCABULARY_BASE.filter(v => normalizeAnswer(v.english) !== normalizeAnswer(correctVocab.english));
            
            const incorrectOptions = shuffleArray(allIncorrect).slice(0, 3).map(v => v.english);
            
            let options = [...incorrectOptions, correctVocab.english];
            
            return shuffleArray(options);
        }

        window.loadNextQuizQuestion = function() {
            quizStatus.textContent = '';
            quizNextButton.classList.add('hidden');
            quizOptionsContainer.innerHTML = '';
            
            if (quizCurrentQuestionIndex >= quizQuestions.length) {
                showQuizResults();
                return;
            }
            
            const currentQuestion = quizQuestions[quizCurrentQuestionIndex];
            
            quizCurrentQuestionElement.textContent = quizCurrentQuestionIndex + 1;
            // Frage: Deutsch
            quizGermanTerm.textContent = currentQuestion.german; 

            currentQuestion.options.forEach(option => {
                const button = document.createElement('button');
                button.classList.add('mc-option', 'w-full', 'text-left');
                button.textContent = option;
                button.onclick = () => handleQuizAnswer(button, option, currentQuestion.english);
                quizOptionsContainer.appendChild(button);
            });
        }

        window.handleQuizAnswer = function(selectedElement, selectedAnswer, correctAnswer) {
            
            document.querySelectorAll('.mc-option').forEach(btn => btn.style.pointerEvents = 'none');
            
            let isCorrect = (normalizeAnswer(selectedAnswer) === normalizeAnswer(correctAnswer));
            
            if (isCorrect) {
                selectedElement.classList.add('correct');
                quizStatus.innerHTML = '<span class="text-green-600 font-bold">âœ… Korrekt!</span>';
                quizScore++;
            } else {
                selectedElement.classList.add('incorrect');
                quizStatus.innerHTML = `<span class="text-red-600 font-bold">âŒ Falsch!</span>`;
                
                document.querySelectorAll('.mc-option').forEach(btn => {
                    if (normalizeAnswer(btn.textContent) === normalizeAnswer(correctAnswer)) {
                        btn.classList.add('correct');
                    }
                });
            }
            
            quizNextButton.classList.remove('hidden');

            quizCurrentQuestionIndex++;
        }
        
        function showQuizResults() {
             quizTimeContainer.classList.add('hidden');
             quizResultsContainer.classList.remove('hidden');
             quizScoreElement.textContent = quizScore;
             document.getElementById('start-quiz-time').disabled = false;
        }

        // --- Fill-in-the-Blank Game (LÃ¼ckenfÃ¼ller) ---

        function initFillInBlankGame() {
            const validVocabs = VOCABULARY_BASE.filter(v => v.example && v.example.includes('[VOCAB]')); 

            if (validVocabs.length < FIB_COUNT) {
                fibStatus.innerHTML = `<span class="text-red-600">âŒ FÃ¼ge mindestens ${FIB_COUNT} Vokabeln mit BeispielsÃ¤tzen hinzu, um das Spiel zu starten!</span>`;
                document.getElementById('start-fill-in-blank').disabled = false;
                return;
            }

            fibResultsContainer.classList.add('hidden');
            fibCurrentQuestionIndex = 0;
            fibScore = 0;
            
            fibQuestions = shuffleArray([...validVocabs]).slice(0, FIB_COUNT);
            
            loadNextFillInBlankQuestion();
        }

        window.loadNextFillInBlankQuestion = function() {
            fibStatus.textContent = '';
            fibAnswerInput.value = '';
            fibAnswerInput.disabled = false;
            fibCheckButton.classList.remove('hidden');
            fibNextButton.classList.add('hidden');
            
            fibSentence.classList.remove('text-left');
            fibSentence.classList.add('text-center');
            fibSentence.innerHTML = '';
            
            fibAnswerInput.focus();

            if (fibCurrentQuestionIndex >= fibQuestions.length) {
                showFibResults();
                return;
            }
            
            const currentQuestion = fibQuestions[fibCurrentQuestionIndex];
            
            fibCurrentQuestionElement.textContent = fibCurrentQuestionIndex + 1;
            // Deutscher Begriff als Hinweis fÃ¼r die LÃ¼cke
            fibGermanTerm.textContent = currentQuestion.german; 
            
            const sentenceWithBlank = currentQuestion.example.replace('[VOCAB]', '_____');
            fibSentence.textContent = sentenceWithBlank;
        }

        window.checkFillInBlankAnswer = function() {
            const currentQuestion = fibQuestions[fibCurrentQuestionIndex];
            const userAnswer = normalizeAnswer(fibAnswerInput.value);
            // Korrekte Antwort ist der englische Begriff
            const correctAnswer = normalizeAnswer(currentQuestion.english); 
            
            fibAnswerInput.disabled = true;
            fibCheckButton.classList.add('hidden');
            fibNextButton.classList.remove('hidden');

            fibSentence.classList.remove('text-center');
            fibSentence.classList.add('text-left');

            if (userAnswer === correctAnswer) {
                fibStatus.innerHTML = '<span class="text-green-600 font-bold">âœ… Korrekt!</span>';
                fibSentence.innerHTML = currentQuestion.example.replace('[VOCAB]', `<span class="font-extrabold text-green-600">${currentQuestion.english}</span>`);
                fibScore++;
            } else {
                fibStatus.innerHTML = `<span class="text-red-600 font-bold">âŒ Falsch! Korrekt wÃ¤re: ${currentQuestion.english}</span>`;
                fibSentence.innerHTML = currentQuestion.example.replace('[VOCAB]', `<span class="font-extrabold text-red-600 underline">${currentQuestion.english}</span>`);
            }

            fibCurrentQuestionIndex++;
        }

        function showFibResults() {
            fillInBlankContainer.classList.add('hidden');
            fibResultsContainer.classList.remove('hidden');
            fibScoreElement.textContent = fibScore;
            document.getElementById('start-fill-in-blank').disabled = false;
        }
        
        // ----------------------------------------------------------------------
        // 10.5 Settings & Progress Tracking
        // ----------------------------------------------------------------------

        function recordTrainingSession(sessionType = 'normal', sessionDetails = null) {
            try {
                const sessions = parseInt(localStorage.getItem(TRAINING_SESSIONS_KEY) || '0');
                localStorage.setItem(TRAINING_SESSIONS_KEY, (sessions + 1).toString());
                localStorage.setItem(LAST_TRAINED_KEY, new Date().toLocaleDateString('de-DE'));
                
                // **NEU: Berechne correct und total aus sessionDetails wenn vorhanden**
                let correctCount = Number(correctAnswersCount) || 0;
                let totalCount = Number(initialDeckSize) || 0;
                
                if (sessionDetails && sessionDetails.length > 0) {
                    totalCount = sessionDetails.length;
                    correctCount = sessionDetails.filter(d => d.isCorrect).length;
                }
                
                // Progress tracking
                let progress = JSON.parse(localStorage.getItem(PROGRESS_KEY) || '[]');
                const today = new Date().toISOString().split('T')[0];
                
                // ÃœberprÃ¼fe, ob heute schon ein Eintrag existiert (aufsummieren statt Ã¼berschreiben)
                const todayEntry = progress.find(p => p.date === today);
                if (todayEntry) {
                    todayEntry.sessions = (todayEntry.sessions || 0) + 1;
                    todayEntry.vocabs = (todayEntry.vocabs || 0) + correctCount;
                } else {
                    progress.push({
                        date: today,
                        sessions: 1,
                        vocabs: correctCount
                    });
                }
                
                localStorage.setItem(PROGRESS_KEY, JSON.stringify(progress));
                
                // **NEU: Speichere detailliertes Trainings-Log mit Zeitstempel und Typ**
                let log = JSON.parse(localStorage.getItem(TRAINING_LOG_KEY) || '[]');
                const now = new Date();
                const timestamp = now.toLocaleString('de-DE', { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                const logEntry = {
                    id: Date.now().toString(),
                    timestamp: timestamp,
                    type: sessionType, // 'normal' oder 'test'
                    correct: correctCount,
                    total: totalCount,
                    successRate: totalCount > 0 ? ((correctCount / totalCount) * 100).toFixed(1) : '0',
                    grade: null, // Wird bei Tests gesetzt
                    details: sessionDetails || [] // Array von { german, english, isCorrect, userAnswer }
                };
                
                log.push(logEntry);
                localStorage.setItem(TRAINING_LOG_KEY, JSON.stringify(log));
            } catch (e) {
                console.error('Fehler beim Speichern der Trainingsstatistiken:', e);
            }
        }

        function updateSettingsStats() {
            try {
                const totalVocabs = document.getElementById('total-vocabs');
                const lastTrained = document.getElementById('last-trained');
                const sessions = document.getElementById('training-sessions');
                
                if (totalVocabs) totalVocabs.textContent = VOCABULARY_BASE.length;
                
                const lastDate = localStorage.getItem(LAST_TRAINED_KEY);
                if (lastTrained) {
                    lastTrained.textContent = lastDate ? lastDate : 'Noch nicht trainiert';
                }
                
                const sessionCount = localStorage.getItem(TRAINING_SESSIONS_KEY);
                if (sessions) sessions.textContent = sessionCount || '0';
                
                // Rendere das Trainings-Log
                renderTrainingLog();
            } catch (e) {
                console.error('Fehler beim Aktualisieren der Statistiken:', e);
            }
        }

        // **NEUE FUNKTION: Rendert das Trainings-Log**
        function renderTrainingLog() {
            try {
                const container = document.getElementById('training-log-container');
                if (!container) return;
                
                const log = JSON.parse(localStorage.getItem(TRAINING_LOG_KEY) || '[]');
                
                if (log.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-400 py-4">Noch keine Trainings-EintrÃ¤ge</div>';
                    return;
                }
                
                // Sortiere Log in umgekehrter Reihenfolge (neueste zuerst) und begrenzte auf die letzten 20
                const sortedLog = log.slice().reverse().slice(0, 20);
                
                let html = '<div class="space-y-2 max-h-96 overflow-y-auto">';
                sortedLog.forEach(entry => {
                    const successRate = parseFloat(entry.successRate || 0);
                    let bgColor = 'bg-red-100';
                    let textColor = 'text-red-700';
                    let typeLabel = entry.type === 'test' ? 'ğŸ“ Test' : 'ğŸ§  Training';
                    let typeStyle = entry.type === 'test' ? 'bg-blue-200 text-blue-800' : 'bg-purple-200 text-purple-800';
                    
                    if (successRate >= 80) {
                        bgColor = 'bg-green-100';
                        textColor = 'text-green-700';
                    } else if (successRate >= 50) {
                        bgColor = 'bg-yellow-100';
                        textColor = 'text-yellow-700';
                    }
                    
                    let gradeDisplay = '';
                    if (entry.type === 'test' && entry.grade) {
                        gradeDisplay = ` | Note: <span class="font-bold">${entry.grade}</span>`;
                    }
                    
                    html += `<div class="p-3 rounded ${bgColor} ${textColor} text-sm cursor-pointer hover:shadow-md transition-shadow" onclick="showSessionDetails('${entry.id}')">
                        <div class="flex justify-between items-start mb-2">
                            <div class="font-medium">${entry.timestamp}</div>
                            <span class="text-xs px-2 py-1 rounded-full ${typeStyle}">${typeLabel}</span>
                        </div>
                        <div class="text-xs mt-1">${entry.correct}/${entry.total} richtig | ${entry.successRate}%${gradeDisplay}</div>
                        <div class="text-xs mt-2 opacity-70">ğŸ‘† Klick fÃ¼r Details</div>
                    </div>`;
                });
                html += '</div>';
                
                container.innerHTML = html;
            } catch (e) {
                console.error('Fehler beim Rendern des Trainings-Logs:', e);
            }
        }

        // **NEUE FUNKTION: Zeigt die Details einer Trainings-Session**
        window.showSessionDetails = function(sessionId) {
            try {
                const log = JSON.parse(localStorage.getItem(TRAINING_LOG_KEY) || '[]');
                const session = log.find(s => s.id === sessionId);
                
                if (!session) return;
                
                let html = `
                    <div class="p-6">
                        <h3 class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3">
                            ${session.type === 'test' ? 'ğŸ“ Vokabel-Test' : 'ğŸ§  Training'} - ${session.timestamp}
                        </h3>
                        
                        <div class="grid grid-cols-2 gap-3 mb-6">
                            <div class="p-3 bg-blue-100 rounded text-center">
                                <p class="text-xs text-gray-600">Korrekt</p>
                                <p class="text-2xl font-bold text-blue-600">${session.correct}</p>
                            </div>
                            <div class="p-3 bg-red-100 rounded text-center">
                                <p class="text-xs text-gray-600">Falsch</p>
                                <p class="text-2xl font-bold text-red-600">${session.total - session.correct}</p>
                            </div>
                        </div>
                        
                        <div class="p-3 bg-gray-100 rounded text-center mb-6">
                            <p class="text-xs text-gray-600">Erfolgsquote</p>
                            <p class="text-3xl font-extrabold text-gray-800">${session.successRate}%</p>
                            ${session.grade ? `<p class="text-sm text-gray-600 mt-2">Note: <span class="font-bold text-lg">${session.grade}</span></p>` : ''}
                        </div>
                        
                        <h4 class="text-lg font-bold text-gray-800 mb-3 border-t pt-3">Gelernte Vokabeln:</h4>
                        <div class="space-y-2 max-h-96 overflow-y-auto">
                `;
                
                if (session.details && session.details.length > 0) {
                    session.details.forEach(detail => {
                        const statusColor = detail.isCorrect ? 'bg-green-100 border-green-400' : 'bg-red-100 border-red-400';
                        const statusIcon = detail.isCorrect ? 'âœ…' : 'âŒ';
                        const statusText = detail.isCorrect ? 'Richtig' : 'Falsch';
                        
                        html += `
                            <div class="p-3 rounded border-l-4 ${statusColor}">
                                <div class="flex justify-between items-start mb-2">
                                    <span class="font-bold text-gray-800">${detail.german}</span>
                                    <span class="text-sm font-bold">${statusIcon} ${statusText}</span>
                                </div>
                                <div class="text-sm text-gray-700">
                                    <span class="font-semibold">Antwort:</span> ${detail.english}
                                </div>
                                ${detail.userAnswer ? `<div class="text-sm text-gray-600 mt-1">
                                    <span class="font-semibold">Deine Antwort:</span> ${detail.userAnswer}
                                </div>` : ''}
                            </div>
                        `;
                    });
                } else {
                    html += '<div class="text-center text-gray-400 py-4">Keine Details verfÃ¼gbar</div>';
                }
                
                html += `
                        </div>
                        <button class="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded transition" onclick="closeSessionModal()">
                            â† ZurÃ¼ck
                        </button>
                    </div>
                `;
                
                // Zeige Modal
                const modal = document.getElementById('session-details-modal');
                if (modal) {
                    modal.querySelector('#session-details-content').innerHTML = html;
                    modal.classList.remove('hidden');
                }
            } catch (e) {
                console.error('Fehler beim Anzeigen der Session-Details:', e);
            }
        };

        window.closeSessionModal = function() {
            const modal = document.getElementById('session-details-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };

        // **NEUE FUNKTION: Rendert das Progress-Chart**
        function renderProgressChart() {
            try {
                // Lade gespeicherte Fortschrittsdaten (array von {date: 'YYYY-MM-DD', sessions: N, vocabs: M})
                let progress = JSON.parse(localStorage.getItem(PROGRESS_KEY) || '[]');

                // Erstelle Zeitachse: letzte 30 Tage (inkl. heute)
                const DAYS = 30;
                const labels = [];
                const countsMap = {};
                for (let i = DAYS - 1; i >= 0; i--) {
                    const d = new Date();
                    d.setDate(d.getDate() - i);
                    const iso = d.toISOString().split('T')[0];
                    labels.push(d.toLocaleDateString('de-DE', { month: 'short', day: 'numeric' }));
                    countsMap[iso] = 0;
                }

                // Summiere vorhandene Progress-Daten pro Tag
                if (Array.isArray(progress) && progress.length > 0) {
                    progress.forEach(p => {
                        if (!p || !p.date) return;
                        // p.date wird als 'YYYY-MM-DD' gespeichert
                        const key = p.date;
                        const val = Number(p.vocabs) || 0;
                        if (countsMap.hasOwnProperty(key)) {
                            countsMap[key] += val;
                        }
                    });
                }

                // Baue das Array fÃ¼r Chart-Daten in der gleichen Reihenfolge wie labels
                const vocabCounts = [];
                const now = new Date();
                for (let i = DAYS - 1; i >= 0; i--) {
                    const d = new Date();
                    d.setDate(d.getDate() - i);
                    const iso = d.toISOString().split('T')[0];
                    vocabCounts.push(countsMap[iso] || 0);
                }

                const ctx = document.getElementById('progressChart');
                if (!ctx) return;

                // ZerstÃ¶re altes Chart, falls vorhanden
                if (window.progressChartInstance) {
                    window.progressChartInstance.destroy();
                }

                window.progressChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Gelernte Vokabeln pro Tag',
                                data: vocabCounts,
                                borderColor: '#3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderWidth: 3,
                                fill: true,
                                tension: 0.4,
                                pointRadius: 5,
                                pointBackgroundColor: '#3b82f6',
                                pointBorderColor: '#fff',
                                pointBorderWidth: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: {
                                    font: { size: 12 },
                                    color: '#374151'
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: '#6b7280',
                                    font: { size: 12 }
                                },
                                grid: {
                                    color: '#e5e7eb'
                                }
                            },
                            x: {
                                ticks: {
                                    color: '#6b7280',
                                    font: { size: 11 }
                                },
                                grid: {
                                    display: false
                                }
                            }
                        }
                    }
                });
            } catch (e) {
                console.error('Fehler beim Rendern des Progress-Charts:', e);
            }
        }

        // **NEUE FUNKTION: Berechnet den aktuellen Streak**
        function calculateStreak() {
            try {
                let progress = JSON.parse(localStorage.getItem(PROGRESS_KEY) || '[]');
                
                if (progress.length === 0) return 0;
                
                // Sortiere nach Datum (neueste zuerst)
                progress.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                const today = new Date().toISOString().split('T')[0];
                const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];
                
                // PrÃ¼fe, ob heute oder gestern trainiert wurde
                if (progress[0].date !== today && progress[0].date !== yesterday) {
                    return 0; // Streak unterbrochen
                }
                
                // ZÃ¤hle aufeinanderfolgende Tage
                let streak = 0;
                let currentDate = new Date();
                
                for (let i = 0; i < 365; i++) {
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const hasEntry = progress.some(p => p.date === dateStr);
                    
                    if (hasEntry) {
                        streak++;
                        currentDate.setDate(currentDate.getDate() - 1);
                    } else {
                        break;
                    }
                }
                
                return streak;
            } catch (e) {
                console.error('Fehler beim Berechnen des Streaks:', e);
                return 0;
            }
        }

        // **NEUE FUNKTION: Aktualisiert die Streak-Anzeige**
        function updateStreakDisplay() {
            const streak = calculateStreak();
            const streakElement = document.getElementById('streak-display');
            if (streakElement) {
                streakElement.textContent = `ğŸ”¥ ${streak}`;
            }
        }

        // **NEUE FUNKTION: Ã–ffnet das Edit-Modal**
        let currentEditingVocab = null;
        window.openEditVocabModal = function(vocabCard) {
            currentEditingVocab = vocabCard;
            document.getElementById('edit-german-input').value = vocabCard.german;
            document.getElementById('edit-english-input').value = vocabCard.english;
            document.getElementById('edit-example-input').value = vocabCard.example || '';
            document.getElementById('edit-vocab-modal').classList.remove('hidden');
        }

        // **NEUE FUNKTION: SchlieÃŸt das Edit-Modal**
        window.closeEditVocabModal = function() {
            document.getElementById('edit-vocab-modal').classList.add('hidden');
            currentEditingVocab = null;
        }

        // **NEUE FUNKTION: Speichert die bearbeitete Vokabel**
        window.saveEditedVocab = function() {
            if (!currentEditingVocab) return;
            
            const newGerman = document.getElementById('edit-german-input').value.trim();
            const newEnglish = document.getElementById('edit-english-input').value.trim();
            const newExample = document.getElementById('edit-example-input').value.trim();
            
            if (!newGerman || !newEnglish) {
                alert('âŒ Deutsch und Englisch mÃ¼ssen ausgefÃ¼llt sein!');
                return;
            }
            
            // Finde die Vokabel im VOCABULARY_BASE
            const vocabIndex = VOCABULARY_BASE.findIndex(v => 
                v.german === currentEditingVocab.german && v.english === currentEditingVocab.english
            );
            
            if (vocabIndex > -1) {
                // Update die Vokabel
                VOCABULARY_BASE[vocabIndex].german = newGerman;
                VOCABULARY_BASE[vocabIndex].english = newEnglish;
                VOCABULARY_BASE[vocabIndex].example = newExample || `You need to learn the English word for "${newGerman}". The correct word is [VOCAB].`;
                
                saveVocabulary();
                renderBoxStats();
                renderBoxStatsHome();
                
                // Refresh die Liste
                const filterBox = null;
                renderVocabularyList(filterBox);
                
                closeEditVocabModal();
                alert('âœ… Vokabel erfolgreich aktualisiert!');
            }
        }

        window.confirmClearDatabase = function() {
            const confirmed = confirm(
                'âš ï¸ WARNUNG: Alle Ihre Vokabeln und Lernfortschritte werden gelÃ¶scht!\n\n' +
                'Dies kann NICHT rÃ¼ckgÃ¤ngig gemacht werden.\n\n' +
                'MÃ¶chten Sie fortfahren?'
            );
            
            if (confirmed) {
                const doubleConfirm = confirm('Sind Sie wirklich sicher? Geben Sie "JA" ein zum BestÃ¤tigen:\n\nTypen Sie: JA');
                if (doubleConfirm) {
                    clearDatabase();
                }
            }
        }

        function clearDatabase() {
            try {
                // LÃ¶sche alle relevanten Keys
                localStorage.removeItem(STORAGE_KEY);
                localStorage.removeItem(SELECTED_BOXES_KEY);
                localStorage.removeItem(PROGRESS_KEY);
                localStorage.removeItem(TRAINING_SESSIONS_KEY);
                localStorage.removeItem(LAST_TRAINED_KEY);
                localStorage.removeItem(DIRECTION_KEY);
                localStorage.removeItem(TRAINING_LOG_KEY);
                
                // Reload die Seite
                alert('âœ… Datenbank erfolgreich gelÃ¶scht! Die Seite wird neu geladen.');
                location.reload();
            } catch (e) {
                alert('âŒ Fehler beim LÃ¶schen der Datenbank: ' + e.message);
            }
        }
        
        // ---------- NEU: Nur Vokabeln zurÃ¼cksetzen (Fortschritt bleibt) ----------
        window.confirmResetVocabularyOnly = function() {
            const confirmed = confirm('MÃ¶chten Sie wirklich nur die Vokabeln auf die Standard-Vokabeln zurÃ¼cksetzen? Ihr Trainingsfortschritt bleibt erhalten.');
            if (!confirmed) return;
            resetVocabularyOnly();
        }

        function resetVocabularyOnly() {
            try {
                // Schreibe nur die DEFAULT_VOCABULARY in den Storage
                localStorage.setItem(STORAGE_KEY, JSON.stringify(DEFAULT_VOCABULARY));

                // NICHT lÃ¶schen: Fortschritt, Sessions, Logs, etc.
                // Setze nur die Kasten-Auswahl auf Standard (Box 1)
                localStorage.setItem(SELECTED_BOXES_KEY, JSON.stringify([1]));

                // Lade die Vokabeln neu in die Laufzeit-Variable
                loadVocabulary();
                saveSelectedBoxes();

                // UI-Aktualisierungen
                try { renderBoxStatsHome(); } catch(e) {}
                try { renderBoxStats(); } catch(e) {}
                try { updateSettingsStats(); } catch(e) {}

                alert('âœ… Vokabeln wurden zurÃ¼ckgesetzt. Ihr Trainingsfortschritt bleibt erhalten.');
                showView('home');
            } catch (e) {
                console.error('Fehler beim ZurÃ¼cksetzen der Vokabeln:', e);
                alert('âŒ Fehler beim ZurÃ¼cksetzen der Vokabeln. Bitte prÃ¼fen Sie die Konsole.');
            }
        }

        // ---------- NEU: Werkseinstellungen zurÃ¼cksetzen (Default-Vokabeln laden) ----------
        window.confirmResetToDefaults = function() {
            const confirmed = confirm('MÃ¶chten Sie wirklich alle Fortschrittsdaten zurÃ¼cksetzen und die Standard-Vokabeln laden?');
            if (!confirmed) return;
            resetToDefaults();
        }

        function resetToDefaults() {
            try {
                // Schreibe die DEFAULT_VOCABULARY in den Storage
                localStorage.setItem(STORAGE_KEY, JSON.stringify(DEFAULT_VOCABULARY));

                // Entferne Fortschritts-/Sitzungsdaten
                localStorage.removeItem(PROGRESS_KEY);
                localStorage.removeItem(TRAINING_SESSIONS_KEY);
                localStorage.removeItem(LAST_TRAINED_KEY);
                localStorage.removeItem(TRAINING_LOG_KEY);

                // Setze Auswahl der Boxen auf Standard (Box 1)
                localStorage.setItem(SELECTED_BOXES_KEY, JSON.stringify([1]));

                // Lade die Vokabeln neu in die Laufzeit-Variable
                loadVocabulary();
                saveSelectedBoxes();

                // UI-Aktualisierungen
                try { renderBoxStatsHome(); } catch(e) {}
                try { renderBoxStats(); } catch(e) {}
                try { updateSettingsStats(); } catch(e) {}

                alert('âœ… Daten wurden zurÃ¼ckgesetzt und Standard-Vokabeln geladen.');
                showView('home');
            } catch (e) {
                console.error('Fehler beim ZurÃ¼cksetzen auf Werkseinstellungen:', e);
                alert('âŒ Fehler beim ZurÃ¼cksetzen der Daten. Bitte prÃ¼fen Sie die Konsole.');
            }
        }

        // ----------------------------------------------------------------------
        // 10.6 Testplan-Kalender
        // ----------------------------------------------------------------------
        
        function loadScheduledTests() {
            try {
                const stored = localStorage.getItem(SCHEDULED_TESTS_KEY);
                return stored ? JSON.parse(stored) : [];
            } catch (e) {
                console.error('Fehler beim Laden der geplanten Tests:', e);
                return [];
            }
        }

        function saveScheduledTests(tests) {
            try {
                localStorage.setItem(SCHEDULED_TESTS_KEY, JSON.stringify(tests));
            } catch (e) {
                console.error('Fehler beim Speichern der geplanten Tests:', e);
            }
        }

        window.addScheduledTest = function(dateStr) {
            // Wenn keine Datum Ã¼bergeben, nichts tun
            if (!dateStr) return;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const testDate = new Date(dateStr);

            if (testDate < today) {
                alert('âŒ Das Datum liegt in der Vergangenheit');
                return;
            }

            const tests = loadScheduledTests();

            if (tests.find(t => t.date === dateStr)) {
                alert('âš ï¸ FÃ¼r diesen Tag existiert bereits ein Test');
                return;
            }

            tests.push({
                date: dateStr,
                progress: 0,
                createdAt: new Date().toISOString()
            });

            saveScheduledTests(tests);
            renderTestCalendar();
            updateCalendarCountdown();
        };

        window.handleCalendarDayClick = function(dateStr) {
            const tests = loadScheduledTests();
            const hasTest = tests.find(t => t.date === dateStr);
            
            if (hasTest) {
                // Wenn bereits ein Test existiert, zeige Optionen
                return;
            }
            
            // Wenn kein Test, fÃ¼ge einen hinzu
            addScheduledTest(dateStr);
        };

        window.removeScheduledTest = function(dateStr) {
            if (!confirm(`Test am ${new Date(dateStr).toLocaleDateString('de-DE', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })} lÃ¶schen?`)) return;
            
            let tests = loadScheduledTests();
            tests = tests.filter(t => t.date !== dateStr);
            saveScheduledTests(tests);
            renderTestCalendar();
            updateCalendarCountdown();
        };

        window.updateTestProgress = function(dateStr, progress) {
            let tests = loadScheduledTests();
            const test = tests.find(t => t.date === dateStr);
            if (test) {
                test.progress = Math.min(100, Math.max(0, progress));
                saveScheduledTests(tests);
                renderTestCalendar();
            }
        };

        function renderTestCalendar() {
            const container = document.getElementById('weekCalendarContainer');
            const tests = loadScheduledTests();
            const testMap = {};
            
            tests.forEach(test => {
                testMap[test.date] = test;
            });

            container.innerHTML = '';

            // Berechne Montag dieser Woche
            const today = new Date();
            const dayOfWeek = today.getDay();
            const diff = today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
            const monday = new Date(today.setDate(diff));
            monday.setHours(0, 0, 0, 0);

            const weekDays = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
            const today_check = new Date();
            today_check.setHours(0, 0, 0, 0);

            // Erstelle 7 Tage (Montag - Sonntag)
            for (let i = 0; i < 7; i++) {
                const currentDate = new Date(monday);
                currentDate.setDate(currentDate.getDate() + i);
                const dateStr = currentDate.toISOString().split('T')[0];
                const dayNum = currentDate.getDate();
                const weekDay = weekDays[i];
                
                const hasTest = testMap[dateStr];
                const isToday = currentDate.getTime() === today_check.getTime();
                const progress = hasTest ? (hasTest.progress || 0) : 0;

                let dayCard = `
                    <div class="flex flex-col items-center p-3 rounded-2xl border-2 transition-all cursor-pointer hover:shadow-md ${
                        isToday ? 'bg-yellow-50 border-yellow-400 shadow-lg' : (hasTest ? 'bg-blue-100 border-blue-400' : 'bg-gray-50 border-gray-200 hover:border-gray-300')
                    }" onclick="handleCalendarDayClick('${dateStr}')">
                        <p class="text-xs font-bold text-gray-700 mb-1">${weekDay}</p>
                        <p class="text-2xl font-extrabold text-gray-800 mb-2">${dayNum}</p>
                `;

                if (hasTest) {
                    dayCard += `
                        <div class="w-full">
                            <p class="text-xs text-center font-bold text-blue-600 mb-1">ğŸ“ Test</p>
                            <div class="w-full bg-gray-300 rounded-full h-1.5 mb-2">
                                <div class="bg-gradient-to-r from-blue-500 to-purple-600 h-1.5 rounded-full" style="width: ${progress}%"></div>
                            </div>
                            <p class="text-xs text-center font-bold text-blue-600">${progress}%</p>
                            <button onclick="event.stopPropagation(); removeScheduledTest('${dateStr}')" class="mt-1 text-red-500 hover:text-red-700 text-xs font-bold">âœ•</button>
                        </div>
                    `;
                } else {
                    dayCard += `<p class="text-xs text-gray-400">+ Test</p>`;
                }

                dayCard += `</div>`;
                container.innerHTML += dayCard;
            }
        }

        function updateCalendarCountdown() {
            const tests = loadScheduledTests();
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            if (tests.length === 0) {
                document.getElementById('nextTestCountdown').textContent = '-';
                return;
            }

            tests.sort((a, b) => new Date(a.date) - new Date(b.date));
            const nextTest = tests[0];
            const nextDate = new Date(nextTest.date);
            const daysUntil = Math.ceil((nextDate - today) / (1000 * 60 * 60 * 24));

            if (daysUntil <= 0) {
                document.getElementById('nextTestCountdown').textContent = 'HEUTE! ğŸ¯';
            } else if (daysUntil === 1) {
                document.getElementById('nextTestCountdown').textContent = 'Morgen';
            } else {
                document.getElementById('nextTestCountdown').textContent = `${daysUntil} Tage`;
            }
        }

        // ----------------------------------------------------------------------
        // 11. Initialisierung
        // ----------------------------------------------------------------------

        window.onload = function() {
            loadVocabulary(); // Vokabeln aus dem Local Storage laden
            // Load saved direction preference and update UI
            loadCardDirection();
            initialDeckSize = VOCABULARY_BASE.length;
            totalCardsElement.textContent = initialDeckSize;
            updateDirectionUI();
            
            showView('home'); 
        }
    </script>

</body>
</html>
